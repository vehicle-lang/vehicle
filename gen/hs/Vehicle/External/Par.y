-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.3).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Vehicle.External.Par
  ( happyError
  , myLexer
  , pListName
  , pBinder
  , pListBinder
  , pArg
  , pLetDecl
  , pListLetDecl
  , pLit
  , pExpr15
  , pExpr
  , pExpr1
  , pExpr2
  , pExpr11
  , pExpr13
  , pExpr4
  , pExpr5
  , pExpr7
  , pExpr8
  , pExpr9
  , pExpr10
  , pExpr12
  , pExpr14
  , pExpr3
  , pExpr6
  , pListExpr
  , pDeclAnnName
  , pDeclAnnOption
  , pListDeclAnnOption
  , pDeclAnnOpts
  , pDecl
  , pListDecl
  , pProg
  ) where

import Prelude

import qualified Vehicle.External.Abs
import Vehicle.External.Lex
import qualified Data.Text

}

%name pListName ListName
%name pBinder Binder
%name pListBinder ListBinder
%name pArg Arg
%name pLetDecl LetDecl
%name pListLetDecl ListLetDecl
%name pLit Lit
%name pExpr15 Expr15
%name pExpr Expr
%name pExpr1 Expr1
%name pExpr2 Expr2
%name pExpr11 Expr11
%name pExpr13 Expr13
%name pExpr4 Expr4
%name pExpr5 Expr5
%name pExpr7 Expr7
%name pExpr8 Expr8
%name pExpr9 Expr9
%name pExpr10 Expr10
%name pExpr12 Expr12
%name pExpr14 Expr14
%name pExpr3 Expr3
%name pExpr6 Expr6
%name pListExpr ListExpr
%name pDeclAnnName DeclAnnName
%name pDeclAnnOption DeclAnnOption
%name pListDeclAnnOption ListDeclAnnOption
%name pDeclAnnOpts DeclAnnOpts
%name pDecl Decl
%name pListDecl ListDecl
%name pProg Prog
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('                  { PT _ (TS _ 1)                 }
  '()'                 { PT _ (TS _ 2)                 }
  ')'                  { PT _ (TS _ 3)                 }
  ','                  { PT _ (TS _ 4)                 }
  ';'                  { PT _ (TS _ 5)                 }
  '='                  { PT _ (TS _ 6)                 }
  'in'                 { PT _ (TS _ 7)                 }
  'type'               { PT _ (TS _ 8)                 }
  '{'                  { PT _ (TS _ 9)                 }
  '{{'                 { PT _ (TS _ 10)                }
  '}'                  { PT _ (TS _ 11)                }
  '}}'                 { PT _ (TS _ 12)                }
  L_Boolean            { PT _ (T_Boolean _)            }
  L_Natural            { PT _ (T_Natural _)            }
  L_Rational           { PT _ (T_Rational _)           }
  L_TokNetwork         { PT _ (T_TokNetwork _)         }
  L_TokDataset         { PT _ (T_TokDataset _)         }
  L_TokParameter       { PT _ (T_TokParameter _)       }
  L_TokProperty        { PT _ (T_TokProperty _)        }
  L_TokArrow           { PT _ (T_TokArrow _)           }
  L_TokForallT         { PT _ (T_TokForallT _)         }
  L_TokIf              { PT _ (T_TokIf _)              }
  L_TokThen            { PT _ (T_TokThen _)            }
  L_TokElse            { PT _ (T_TokElse _)            }
  L_TokDot             { PT _ (T_TokDot _)             }
  L_TokElemOf          { PT _ (T_TokElemOf _)          }
  L_TokLambda          { PT _ (T_TokLambda _)          }
  L_TokLet             { PT _ (T_TokLet _)             }
  L_TokUnit            { PT _ (T_TokUnit _)            }
  L_TokBool            { PT _ (T_TokBool _)            }
  L_TokNat             { PT _ (T_TokNat _)             }
  L_TokInt             { PT _ (T_TokInt _)             }
  L_TokRat             { PT _ (T_TokRat _)             }
  L_TokVector          { PT _ (T_TokVector _)          }
  L_TokTensor          { PT _ (T_TokTensor _)          }
  L_TokList            { PT _ (T_TokList _)            }
  L_TokIndex           { PT _ (T_TokIndex _)           }
  L_TokForall          { PT _ (T_TokForall _)          }
  L_TokExists          { PT _ (T_TokExists _)          }
  L_TokForeach         { PT _ (T_TokForeach _)         }
  L_TokImpl            { PT _ (T_TokImpl _)            }
  L_TokAnd             { PT _ (T_TokAnd _)             }
  L_TokOr              { PT _ (T_TokOr _)              }
  L_TokNot             { PT _ (T_TokNot _)             }
  L_TokEq              { PT _ (T_TokEq _)              }
  L_TokNeq             { PT _ (T_TokNeq _)             }
  L_TokLe              { PT _ (T_TokLe _)              }
  L_TokLt              { PT _ (T_TokLt _)              }
  L_TokGe              { PT _ (T_TokGe _)              }
  L_TokGt              { PT _ (T_TokGt _)              }
  L_TokMul             { PT _ (T_TokMul _)             }
  L_TokDiv             { PT _ (T_TokDiv _)             }
  L_TokAdd             { PT _ (T_TokAdd _)             }
  L_TokSub             { PT _ (T_TokSub _)             }
  L_TokNil             { PT _ (T_TokNil _)             }
  L_TokSeqOpen         { PT _ (T_TokSeqOpen _)         }
  L_TokSeqClose        { PT _ (T_TokSeqClose _)        }
  L_TokCons            { PT _ (T_TokCons _)            }
  L_TokAt              { PT _ (T_TokAt _)              }
  L_TokMap             { PT _ (T_TokMap _)             }
  L_TokFold            { PT _ (T_TokFold _)            }
  L_Name               { PT _ (T_Name _)               }
  L_HoleToken          { PT _ (T_HoleToken _)          }
  L_TypeToken          { PT _ (T_TypeToken _)          }
  L_DeclAnnOptionValue { PT _ (T_DeclAnnOptionValue _) }

%%

Boolean :: { Vehicle.External.Abs.Boolean }
Boolean  : L_Boolean { Vehicle.External.Abs.Boolean (mkPosToken $1) }

Natural :: { Vehicle.External.Abs.Natural }
Natural  : L_Natural { Vehicle.External.Abs.Natural (mkPosToken $1) }

Rational :: { Vehicle.External.Abs.Rational }
Rational  : L_Rational { Vehicle.External.Abs.Rational (mkPosToken $1) }

TokNetwork :: { Vehicle.External.Abs.TokNetwork }
TokNetwork  : L_TokNetwork { Vehicle.External.Abs.TokNetwork (mkPosToken $1) }

TokDataset :: { Vehicle.External.Abs.TokDataset }
TokDataset  : L_TokDataset { Vehicle.External.Abs.TokDataset (mkPosToken $1) }

TokParameter :: { Vehicle.External.Abs.TokParameter }
TokParameter  : L_TokParameter { Vehicle.External.Abs.TokParameter (mkPosToken $1) }

TokProperty :: { Vehicle.External.Abs.TokProperty }
TokProperty  : L_TokProperty { Vehicle.External.Abs.TokProperty (mkPosToken $1) }

TokArrow :: { Vehicle.External.Abs.TokArrow }
TokArrow  : L_TokArrow { Vehicle.External.Abs.TokArrow (mkPosToken $1) }

TokForallT :: { Vehicle.External.Abs.TokForallT }
TokForallT  : L_TokForallT { Vehicle.External.Abs.TokForallT (mkPosToken $1) }

TokIf :: { Vehicle.External.Abs.TokIf }
TokIf  : L_TokIf { Vehicle.External.Abs.TokIf (mkPosToken $1) }

TokThen :: { Vehicle.External.Abs.TokThen }
TokThen  : L_TokThen { Vehicle.External.Abs.TokThen (mkPosToken $1) }

TokElse :: { Vehicle.External.Abs.TokElse }
TokElse  : L_TokElse { Vehicle.External.Abs.TokElse (mkPosToken $1) }

TokDot :: { Vehicle.External.Abs.TokDot }
TokDot  : L_TokDot { Vehicle.External.Abs.TokDot (mkPosToken $1) }

TokElemOf :: { Vehicle.External.Abs.TokElemOf }
TokElemOf  : L_TokElemOf { Vehicle.External.Abs.TokElemOf (mkPosToken $1) }

TokLambda :: { Vehicle.External.Abs.TokLambda }
TokLambda  : L_TokLambda { Vehicle.External.Abs.TokLambda (mkPosToken $1) }

TokLet :: { Vehicle.External.Abs.TokLet }
TokLet  : L_TokLet { Vehicle.External.Abs.TokLet (mkPosToken $1) }

TokUnit :: { Vehicle.External.Abs.TokUnit }
TokUnit  : L_TokUnit { Vehicle.External.Abs.TokUnit (mkPosToken $1) }

TokBool :: { Vehicle.External.Abs.TokBool }
TokBool  : L_TokBool { Vehicle.External.Abs.TokBool (mkPosToken $1) }

TokNat :: { Vehicle.External.Abs.TokNat }
TokNat  : L_TokNat { Vehicle.External.Abs.TokNat (mkPosToken $1) }

TokInt :: { Vehicle.External.Abs.TokInt }
TokInt  : L_TokInt { Vehicle.External.Abs.TokInt (mkPosToken $1) }

TokRat :: { Vehicle.External.Abs.TokRat }
TokRat  : L_TokRat { Vehicle.External.Abs.TokRat (mkPosToken $1) }

TokVector :: { Vehicle.External.Abs.TokVector }
TokVector  : L_TokVector { Vehicle.External.Abs.TokVector (mkPosToken $1) }

TokTensor :: { Vehicle.External.Abs.TokTensor }
TokTensor  : L_TokTensor { Vehicle.External.Abs.TokTensor (mkPosToken $1) }

TokList :: { Vehicle.External.Abs.TokList }
TokList  : L_TokList { Vehicle.External.Abs.TokList (mkPosToken $1) }

TokIndex :: { Vehicle.External.Abs.TokIndex }
TokIndex  : L_TokIndex { Vehicle.External.Abs.TokIndex (mkPosToken $1) }

TokForall :: { Vehicle.External.Abs.TokForall }
TokForall  : L_TokForall { Vehicle.External.Abs.TokForall (mkPosToken $1) }

TokExists :: { Vehicle.External.Abs.TokExists }
TokExists  : L_TokExists { Vehicle.External.Abs.TokExists (mkPosToken $1) }

TokForeach :: { Vehicle.External.Abs.TokForeach }
TokForeach  : L_TokForeach { Vehicle.External.Abs.TokForeach (mkPosToken $1) }

TokImpl :: { Vehicle.External.Abs.TokImpl }
TokImpl  : L_TokImpl { Vehicle.External.Abs.TokImpl (mkPosToken $1) }

TokAnd :: { Vehicle.External.Abs.TokAnd }
TokAnd  : L_TokAnd { Vehicle.External.Abs.TokAnd (mkPosToken $1) }

TokOr :: { Vehicle.External.Abs.TokOr }
TokOr  : L_TokOr { Vehicle.External.Abs.TokOr (mkPosToken $1) }

TokNot :: { Vehicle.External.Abs.TokNot }
TokNot  : L_TokNot { Vehicle.External.Abs.TokNot (mkPosToken $1) }

TokEq :: { Vehicle.External.Abs.TokEq }
TokEq  : L_TokEq { Vehicle.External.Abs.TokEq (mkPosToken $1) }

TokNeq :: { Vehicle.External.Abs.TokNeq }
TokNeq  : L_TokNeq { Vehicle.External.Abs.TokNeq (mkPosToken $1) }

TokLe :: { Vehicle.External.Abs.TokLe }
TokLe  : L_TokLe { Vehicle.External.Abs.TokLe (mkPosToken $1) }

TokLt :: { Vehicle.External.Abs.TokLt }
TokLt  : L_TokLt { Vehicle.External.Abs.TokLt (mkPosToken $1) }

TokGe :: { Vehicle.External.Abs.TokGe }
TokGe  : L_TokGe { Vehicle.External.Abs.TokGe (mkPosToken $1) }

TokGt :: { Vehicle.External.Abs.TokGt }
TokGt  : L_TokGt { Vehicle.External.Abs.TokGt (mkPosToken $1) }

TokMul :: { Vehicle.External.Abs.TokMul }
TokMul  : L_TokMul { Vehicle.External.Abs.TokMul (mkPosToken $1) }

TokDiv :: { Vehicle.External.Abs.TokDiv }
TokDiv  : L_TokDiv { Vehicle.External.Abs.TokDiv (mkPosToken $1) }

TokAdd :: { Vehicle.External.Abs.TokAdd }
TokAdd  : L_TokAdd { Vehicle.External.Abs.TokAdd (mkPosToken $1) }

TokSub :: { Vehicle.External.Abs.TokSub }
TokSub  : L_TokSub { Vehicle.External.Abs.TokSub (mkPosToken $1) }

TokNil :: { Vehicle.External.Abs.TokNil }
TokNil  : L_TokNil { Vehicle.External.Abs.TokNil (mkPosToken $1) }

TokSeqOpen :: { Vehicle.External.Abs.TokSeqOpen }
TokSeqOpen  : L_TokSeqOpen { Vehicle.External.Abs.TokSeqOpen (mkPosToken $1) }

TokSeqClose :: { Vehicle.External.Abs.TokSeqClose }
TokSeqClose  : L_TokSeqClose { Vehicle.External.Abs.TokSeqClose (mkPosToken $1) }

TokCons :: { Vehicle.External.Abs.TokCons }
TokCons  : L_TokCons { Vehicle.External.Abs.TokCons (mkPosToken $1) }

TokAt :: { Vehicle.External.Abs.TokAt }
TokAt  : L_TokAt { Vehicle.External.Abs.TokAt (mkPosToken $1) }

TokMap :: { Vehicle.External.Abs.TokMap }
TokMap  : L_TokMap { Vehicle.External.Abs.TokMap (mkPosToken $1) }

TokFold :: { Vehicle.External.Abs.TokFold }
TokFold  : L_TokFold { Vehicle.External.Abs.TokFold (mkPosToken $1) }

Name :: { Vehicle.External.Abs.Name }
Name  : L_Name { Vehicle.External.Abs.Name (mkPosToken $1) }

HoleToken :: { Vehicle.External.Abs.HoleToken }
HoleToken  : L_HoleToken { Vehicle.External.Abs.HoleToken (mkPosToken $1) }

TypeToken :: { Vehicle.External.Abs.TypeToken }
TypeToken  : L_TypeToken { Vehicle.External.Abs.TypeToken (mkPosToken $1) }

DeclAnnOptionValue :: { Vehicle.External.Abs.DeclAnnOptionValue }
DeclAnnOptionValue  : L_DeclAnnOptionValue { Vehicle.External.Abs.DeclAnnOptionValue (mkPosToken $1) }

ListName :: { [Vehicle.External.Abs.Name] }
ListName : {- empty -} { [] } | Name ListName { (:) $1 $2 }

Binder :: { Vehicle.External.Abs.Binder }
Binder
  : Name { Vehicle.External.Abs.ExplicitBinder $1 }
  | '(' Name TokElemOf Expr1 ')' { Vehicle.External.Abs.ExplicitBinderAnn $2 $3 $4 }
  | '{' Name '}' { Vehicle.External.Abs.ImplicitBinder $2 }
  | '{' Name TokElemOf Expr1 '}' { Vehicle.External.Abs.ImplicitBinderAnn $2 $3 $4 }
  | '{{' Name '}}' { Vehicle.External.Abs.InstanceBinder $2 }
  | '{{' Name TokElemOf Expr1 '}}' { Vehicle.External.Abs.InstanceBinderAnn $2 $3 $4 }

ListBinder :: { [Vehicle.External.Abs.Binder] }
ListBinder : {- empty -} { [] } | Binder ListBinder { (:) $1 $2 }

Arg :: { Vehicle.External.Abs.Arg }
Arg
  : Expr15 { Vehicle.External.Abs.ExplicitArg $1 }
  | '{' Expr1 '}' { Vehicle.External.Abs.ImplicitArg $2 }
  | '{{' Expr1 '}}' { Vehicle.External.Abs.InstanceArg $2 }

LetDecl :: { Vehicle.External.Abs.LetDecl }
LetDecl : Binder '=' Expr { Vehicle.External.Abs.LDecl $1 $3 }

ListLetDecl :: { [Vehicle.External.Abs.LetDecl] }
ListLetDecl
  : {- empty -} { [] }
  | LetDecl { (:[]) $1 }
  | LetDecl ',' ListLetDecl { (:) $1 $3 }

Lit :: { Vehicle.External.Abs.Lit }
Lit
  : '()' { Vehicle.External.Abs.UnitLiteral }
  | Natural { Vehicle.External.Abs.NatLiteral $1 }
  | Rational { Vehicle.External.Abs.RatLiteral $1 }
  | Boolean { Vehicle.External.Abs.BoolLiteral $1 }

Expr15 :: { Vehicle.External.Abs.Expr }
Expr15
  : TypeToken { Vehicle.External.Abs.Type $1 }
  | Name { Vehicle.External.Abs.Var $1 }
  | Lit { Vehicle.External.Abs.Literal $1 }
  | HoleToken { Vehicle.External.Abs.Hole $1 }
  | TokSeqOpen ListExpr TokSeqClose { Vehicle.External.Abs.VecLiteral $1 $2 $3 }
  | TokNil { Vehicle.External.Abs.Nil $1 }
  | TokUnit { Vehicle.External.Abs.Unit $1 }
  | TokBool { Vehicle.External.Abs.Bool $1 }
  | TokRat { Vehicle.External.Abs.Rat $1 }
  | TokInt { Vehicle.External.Abs.Int $1 }
  | TokNat { Vehicle.External.Abs.Nat $1 }
  | '(' Expr ')' { $2 }

Expr :: { Vehicle.External.Abs.Expr }
Expr
  : Expr2 TokElemOf Expr1 { Vehicle.External.Abs.Ann $1 $2 $3 }
  | Expr1 { $1 }

Expr1 :: { Vehicle.External.Abs.Expr }
Expr1
  : TokForallT ListBinder TokDot Expr1 { Vehicle.External.Abs.ForallT $1 $2 $3 $4 }
  | Expr2 { $1 }

Expr2 :: { Vehicle.External.Abs.Expr }
Expr2
  : TokLet ListLetDecl 'in' Expr2 { Vehicle.External.Abs.Let $1 $2 $4 }
  | TokLambda ListBinder TokArrow Expr2 { Vehicle.External.Abs.Lam $1 $2 $3 $4 }
  | TokForall ListBinder TokDot Expr2 { Vehicle.External.Abs.Forall $1 $2 $3 $4 }
  | TokExists ListBinder TokDot Expr2 { Vehicle.External.Abs.Exists $1 $2 $3 $4 }
  | TokForall ListBinder 'in' Expr3 TokDot Expr2 { Vehicle.External.Abs.ForallIn $1 $2 $4 $5 $6 }
  | TokExists ListBinder 'in' Expr3 TokDot Expr2 { Vehicle.External.Abs.ExistsIn $1 $2 $4 $5 $6 }
  | TokForeach ListBinder TokDot Expr2 { Vehicle.External.Abs.Foreach $1 $2 $3 $4 }
  | Expr3 { $1 }

Expr11 :: { Vehicle.External.Abs.Expr }
Expr11
  : Expr13 TokArrow Expr11 { Vehicle.External.Abs.Fun $1 $2 $3 }
  | TokNot Expr11 { Vehicle.External.Abs.Not $1 $2 }
  | TokSub Expr11 { Vehicle.External.Abs.Neg $1 $2 }
  | Expr12 { $1 }

Expr13 :: { Vehicle.External.Abs.Expr }
Expr13
  : Expr13 Arg { Vehicle.External.Abs.App $1 $2 }
  | TokMap Expr15 Expr15 { Vehicle.External.Abs.Map $1 $2 $3 }
  | TokFold Expr15 Expr15 Expr15 { Vehicle.External.Abs.Fold $1 $2 $3 $4 }
  | Expr14 { $1 }

Expr4 :: { Vehicle.External.Abs.Expr }
Expr4
  : TokIf Expr5 TokThen Expr5 TokElse Expr5 { Vehicle.External.Abs.If $1 $2 $3 $4 $5 $6 }
  | Expr5 TokCons Expr4 { Vehicle.External.Abs.Cons $1 $2 $3 }
  | Expr5 { $1 }

Expr5 :: { Vehicle.External.Abs.Expr }
Expr5
  : Expr6 TokImpl Expr5 { Vehicle.External.Abs.Impl $1 $2 $3 }
  | Expr6 { $1 }

Expr7 :: { Vehicle.External.Abs.Expr }
Expr7
  : Expr8 TokAnd Expr7 { Vehicle.External.Abs.And $1 $2 $3 }
  | Expr8 TokOr Expr7 { Vehicle.External.Abs.Or $1 $2 $3 }
  | Expr8 { $1 }

Expr8 :: { Vehicle.External.Abs.Expr }
Expr8
  : Expr9 TokEq Expr9 { Vehicle.External.Abs.Eq $1 $2 $3 }
  | Expr9 TokNeq Expr9 { Vehicle.External.Abs.Neq $1 $2 $3 }
  | Expr8 TokLe Expr9 { Vehicle.External.Abs.Le $1 $2 $3 }
  | Expr8 TokLt Expr9 { Vehicle.External.Abs.Lt $1 $2 $3 }
  | Expr8 TokGe Expr9 { Vehicle.External.Abs.Ge $1 $2 $3 }
  | Expr8 TokGt Expr9 { Vehicle.External.Abs.Gt $1 $2 $3 }
  | Expr9 { $1 }

Expr9 :: { Vehicle.External.Abs.Expr }
Expr9
  : Expr9 TokAdd Expr10 { Vehicle.External.Abs.Add $1 $2 $3 }
  | Expr9 TokSub Expr10 { Vehicle.External.Abs.Sub $1 $2 $3 }
  | Expr10 { $1 }

Expr10 :: { Vehicle.External.Abs.Expr }
Expr10
  : Expr10 TokMul Expr11 { Vehicle.External.Abs.Mul $1 $2 $3 }
  | Expr10 TokDiv Expr11 { Vehicle.External.Abs.Div $1 $2 $3 }
  | Expr11 { $1 }

Expr12 :: { Vehicle.External.Abs.Expr }
Expr12
  : Expr12 TokAt Expr13 { Vehicle.External.Abs.At $1 $2 $3 }
  | Expr13 { $1 }

Expr14 :: { Vehicle.External.Abs.Expr }
Expr14
  : TokList Expr15 { Vehicle.External.Abs.List $1 $2 }
  | TokVector Expr15 Expr15 { Vehicle.External.Abs.Vector $1 $2 $3 }
  | TokTensor Expr15 Expr15 { Vehicle.External.Abs.Tensor $1 $2 $3 }
  | TokIndex Expr15 { Vehicle.External.Abs.Index $1 $2 }
  | Expr15 { $1 }

Expr3 :: { Vehicle.External.Abs.Expr }
Expr3 : Expr4 { $1 }

Expr6 :: { Vehicle.External.Abs.Expr }
Expr6 : Expr7 { $1 }

ListExpr :: { [Vehicle.External.Abs.Expr] }
ListExpr
  : {- empty -} { [] }
  | Expr { (:[]) $1 }
  | Expr ',' ListExpr { (:) $1 $3 }

DeclAnnName :: { Vehicle.External.Abs.DeclAnnName }
DeclAnnName
  : TokNetwork { Vehicle.External.Abs.Network $1 }
  | TokDataset { Vehicle.External.Abs.Dataset $1 }
  | TokParameter { Vehicle.External.Abs.Parameter $1 }
  | TokProperty { Vehicle.External.Abs.Property $1 }

DeclAnnOption :: { Vehicle.External.Abs.DeclAnnOption }
DeclAnnOption
  : Name '=' Boolean { Vehicle.External.Abs.BooleanOption $1 $3 }

ListDeclAnnOption :: { [Vehicle.External.Abs.DeclAnnOption] }
ListDeclAnnOption
  : {- empty -} { [] }
  | DeclAnnOption { (:[]) $1 }
  | DeclAnnOption ',' ListDeclAnnOption { (:) $1 $3 }

DeclAnnOpts :: { Vehicle.External.Abs.DeclAnnOpts }
DeclAnnOpts
  : '(' ListDeclAnnOption ')' { Vehicle.External.Abs.DeclAnnWithOpts $2 }
  | {- empty -} { Vehicle.External.Abs.DeclAnnWithoutOpts }

Decl :: { Vehicle.External.Abs.Decl }
Decl
  : DeclAnnName DeclAnnOpts { Vehicle.External.Abs.DefAnn $1 $2 }
  | 'type' Name ListBinder '=' Expr { Vehicle.External.Abs.DefType $2 $3 $5 }
  | Name TokElemOf Expr { Vehicle.External.Abs.DefFunType $1 $2 $3 }
  | Name ListBinder '=' Expr { Vehicle.External.Abs.DefFunExpr $1 $2 $4 }

ListDecl :: { [Vehicle.External.Abs.Decl] }
ListDecl
  : {- empty -} { [] }
  | Decl { (:[]) $1 }
  | Decl ';' ListDecl { (:) $1 $3 }

Prog :: { Vehicle.External.Abs.Prog }
Prog : ListDecl { Vehicle.External.Abs.Main $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

}
