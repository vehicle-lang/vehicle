-- File generated by the BNF Converter (bnfc 2.9.3).

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Internal.

module Vehicle.Internal.Abs where

import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Int, Maybe(..)
  )

import qualified Data.Text
import qualified Data.Data    as C (Data, Typeable)
import qualified GHC.Generics as C (Generic)

data Binder
    = RelevantExplicitBinder NameToken Expr
    | RelevantImplicitBinder NameToken Expr
    | RelevantInstanceBinder NameToken Expr
    | IrrelevantExplicitBinder NameToken Expr
    | IrrelevantImplicitBinder NameToken Expr
    | IrrelevantInstanceBinder NameToken Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Arg
    = RelevantExplicitArg Expr
    | RelevantImplicitArg Expr
    | RelevantInstanceArg Expr
    | IrrelevantExplicitArg Expr
    | IrrelevantImplicitArg Expr
    | IrrelevantInstanceArg Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Lit
    = UnitLiteral
    | NatLiteral Natural
    | RatLiteral Rational
    | BoolLiteral BoolToken
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Expr
    = Ann Expr Expr
    | Pi Binder Expr
    | Let Binder Expr Expr
    | Lam Binder Expr
    | App Expr Arg
    | Type TypeToken
    | Builtin BuiltinToken
    | Var NameToken
    | Literal Lit
    | LVec [Expr]
    | Hole HoleToken
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Decl
    = DeclNetw NameToken Expr
    | DeclData NameToken Expr
    | DeclParam NameToken Expr
    | DeclImplParam NameToken Expr
    | DeclPost NameToken Expr
    | DefFun NameToken Expr Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

data Prog = Main [Decl]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype BuiltinToken = BuiltinToken ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype NameToken = NameToken ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype BoolToken = BoolToken ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype HoleToken = HoleToken ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype TypeToken = TypeToken ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype Natural = Natural ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype Rational = Rational ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition BuiltinToken where
  hasPosition (BuiltinToken (p, _)) = C.Just p

instance HasPosition NameToken where
  hasPosition (NameToken (p, _)) = C.Just p

instance HasPosition BoolToken where
  hasPosition (BoolToken (p, _)) = C.Just p

instance HasPosition HoleToken where
  hasPosition (HoleToken (p, _)) = C.Just p

instance HasPosition TypeToken where
  hasPosition (TypeToken (p, _)) = C.Just p

instance HasPosition Natural where
  hasPosition (Natural (p, _)) = C.Just p

instance HasPosition Rational where
  hasPosition (Rational (p, _)) = C.Just p
