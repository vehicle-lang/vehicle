-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.3).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Vehicle.Internal.Par
  ( happyError
  , myLexer
  , pBinder
  , pArg
  , pLit
  , pExpr
  , pExpr1
  , pListExpr1
  , pDecl
  , pListDecl
  , pProg
  ) where

import Prelude

import qualified Vehicle.Internal.Abs
import Vehicle.Internal.Lex
import qualified Data.Text

}

%name pBinder Binder
%name pArg Arg
%name pLit Lit
%name pExpr Expr
%name pExpr1 Expr1
%name pListExpr1 ListExpr1
%name pDecl Decl
%name pListDecl ListDecl
%name pProg Prog
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('                 { PT _ (TS _ 1)           }
  ')'                 { PT _ (TS _ 2)           }
  ':type'             { PT _ (TS _ 3)           }
  '['                 { PT _ (TS _ 4)           }
  ']'                 { PT _ (TS _ 5)           }
  'declare-dataset'   { PT _ (TS _ 6)           }
  'declare-network'   { PT _ (TS _ 7)           }
  'declare-parameter' { PT _ (TS _ 8)           }
  'define-fun'        { PT _ (TS _ 9)           }
  'lambda'            { PT _ (TS _ 10)          }
  'let'               { PT _ (TS _ 11)          }
  'pi'                { PT _ (TS _ 12)          }
  '{'                 { PT _ (TS _ 13)          }
  '{{'                { PT _ (TS _ 14)          }
  '}'                 { PT _ (TS _ 15)          }
  '}}'                { PT _ (TS _ 16)          }
  L_BuiltinToken      { PT _ (T_BuiltinToken _) }
  L_NameToken         { PT _ (T_NameToken _)    }
  L_BoolToken         { PT _ (T_BoolToken _)    }
  L_HoleToken         { PT _ (T_HoleToken _)    }
  L_TypeToken         { PT _ (T_TypeToken _)    }
  L_Natural           { PT _ (T_Natural _)      }
  L_Rational          { PT _ (T_Rational _)     }

%%

BuiltinToken :: { Vehicle.Internal.Abs.BuiltinToken }
BuiltinToken  : L_BuiltinToken { Vehicle.Internal.Abs.BuiltinToken (mkPosToken $1) }

NameToken :: { Vehicle.Internal.Abs.NameToken }
NameToken  : L_NameToken { Vehicle.Internal.Abs.NameToken (mkPosToken $1) }

BoolToken :: { Vehicle.Internal.Abs.BoolToken }
BoolToken  : L_BoolToken { Vehicle.Internal.Abs.BoolToken (mkPosToken $1) }

HoleToken :: { Vehicle.Internal.Abs.HoleToken }
HoleToken  : L_HoleToken { Vehicle.Internal.Abs.HoleToken (mkPosToken $1) }

TypeToken :: { Vehicle.Internal.Abs.TypeToken }
TypeToken  : L_TypeToken { Vehicle.Internal.Abs.TypeToken (mkPosToken $1) }

Natural :: { Vehicle.Internal.Abs.Natural }
Natural  : L_Natural { Vehicle.Internal.Abs.Natural (mkPosToken $1) }

Rational :: { Vehicle.Internal.Abs.Rational }
Rational  : L_Rational { Vehicle.Internal.Abs.Rational (mkPosToken $1) }

Binder :: { Vehicle.Internal.Abs.Binder }
Binder
  : '(' NameToken ':type' Expr ')' { Vehicle.Internal.Abs.ExplicitBinder $2 $4 }
  | '{' NameToken ':type' Expr '}' { Vehicle.Internal.Abs.ImplicitBinder $2 $4 }
  | '{{' NameToken ':type' Expr '}}' { Vehicle.Internal.Abs.InstanceBinder $2 $4 }

Arg :: { Vehicle.Internal.Abs.Arg }
Arg
  : Expr1 { Vehicle.Internal.Abs.ExplicitArg $1 }
  | '{' Expr '}' { Vehicle.Internal.Abs.ImplicitArg $2 }
  | '{{' Expr '}}' { Vehicle.Internal.Abs.InstanceArg $2 }

Lit :: { Vehicle.Internal.Abs.Lit }
Lit
  : Natural { Vehicle.Internal.Abs.LitNat $1 }
  | Rational { Vehicle.Internal.Abs.LitRat $1 }
  | BoolToken { Vehicle.Internal.Abs.LitBool $1 }

Expr :: { Vehicle.Internal.Abs.Expr }
Expr
  : Expr1 ':type' Expr1 { Vehicle.Internal.Abs.Ann $1 $3 }
  | 'pi' Binder Expr1 { Vehicle.Internal.Abs.Pi $2 $3 }
  | 'let' Binder Expr1 Expr1 { Vehicle.Internal.Abs.Let $2 $3 $4 }
  | 'lambda' Binder Expr1 { Vehicle.Internal.Abs.Lam $2 $3 }
  | Expr1 Arg { Vehicle.Internal.Abs.App $1 $2 }
  | Expr1 { $1 }

Expr1 :: { Vehicle.Internal.Abs.Expr }
Expr1
  : TypeToken { Vehicle.Internal.Abs.Type $1 }
  | BuiltinToken { Vehicle.Internal.Abs.Builtin $1 }
  | NameToken { Vehicle.Internal.Abs.Var $1 }
  | Lit { Vehicle.Internal.Abs.Literal $1 }
  | '[' ListExpr1 ']' { Vehicle.Internal.Abs.LSeq $2 }
  | HoleToken { Vehicle.Internal.Abs.Hole $1 }
  | '(' Expr ')' { $2 }

ListExpr1 :: { [Vehicle.Internal.Abs.Expr] }
ListExpr1 : {- empty -} { [] } | Expr1 ListExpr1 { (:) $1 $2 }

Decl :: { Vehicle.Internal.Abs.Decl }
Decl
  : '(' 'declare-network' NameToken Expr1 ')' { Vehicle.Internal.Abs.DeclNetw $3 $4 }
  | '(' 'declare-dataset' NameToken Expr1 ')' { Vehicle.Internal.Abs.DeclData $3 $4 }
  | '(' 'declare-parameter' NameToken Expr1 ')' { Vehicle.Internal.Abs.DeclParam $3 $4 }
  | '(' 'define-fun' NameToken Expr1 Expr1 ')' { Vehicle.Internal.Abs.DefFun $3 $4 $5 }

ListDecl :: { [Vehicle.Internal.Abs.Decl] }
ListDecl : {- empty -} { [] } | Decl ListDecl { (:) $1 $2 }

Prog :: { Vehicle.Internal.Abs.Prog }
Prog : '(' ListDecl ')' { Vehicle.Internal.Abs.Main $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

}
