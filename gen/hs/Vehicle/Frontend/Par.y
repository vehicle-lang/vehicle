-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.3).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Vehicle.Frontend.Par
  ( happyError
  , myLexer
  , pListName
  , pBinder
  , pListBinder
  , pArg
  , pLetDecl
  , pListLetDecl
  , pLit
  , pExpr15
  , pExpr
  , pExpr1
  , pExpr2
  , pExpr3
  , pExpr13
  , pExpr11
  , pExpr14
  , pExpr5
  , pExpr6
  , pExpr7
  , pExpr8
  , pExpr9
  , pExpr10
  , pExpr4
  , pExpr12
  , pListExpr
  , pDecl
  , pListDecl
  , pProg
  ) where

import Prelude

import qualified Vehicle.Frontend.Abs
import Vehicle.Frontend.Lex
import qualified Data.Text

}

%name pListName ListName
%name pBinder Binder
%name pListBinder ListBinder
%name pArg Arg
%name pLetDecl LetDecl
%name pListLetDecl ListLetDecl
%name pLit Lit
%name pExpr15 Expr15
%name pExpr Expr
%name pExpr1 Expr1
%name pExpr2 Expr2
%name pExpr3 Expr3
%name pExpr13 Expr13
%name pExpr11 Expr11
%name pExpr14 Expr14
%name pExpr5 Expr5
%name pExpr6 Expr6
%name pExpr7 Expr7
%name pExpr8 Expr8
%name pExpr9 Expr9
%name pExpr10 Expr10
%name pExpr4 Expr4
%name pExpr12 Expr12
%name pListExpr ListExpr
%name pDecl Decl
%name pListDecl ListDecl
%name pProg Prog
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('              { PT _ (TS _ 1)             }
  ')'              { PT _ (TS _ 2)             }
  ','              { PT _ (TS _ 3)             }
  ';'              { PT _ (TS _ 4)             }
  '='              { PT _ (TS _ 5)             }
  'Type'           { PT _ (TS _ 6)             }
  'dataset'        { PT _ (TS _ 7)             }
  'in'             { PT _ (TS _ 8)             }
  'inn'            { PT _ (TS _ 9)             }
  'let'            { PT _ (TS _ 10)            }
  'network'        { PT _ (TS _ 11)            }
  'type'           { PT _ (TS _ 12)            }
  '{'              { PT _ (TS _ 13)            }
  '{{'             { PT _ (TS _ 14)            }
  '}'              { PT _ (TS _ 15)            }
  '}}'             { PT _ (TS _ 16)            }
  L_integ          { PT _ (TI $$)              }
  L_TokArrow       { PT _ (T_TokArrow _)       }
  L_TokForallT     { PT _ (T_TokForallT _)     }
  L_TokIf          { PT _ (T_TokIf _)          }
  L_TokThen        { PT _ (T_TokThen _)        }
  L_TokElse        { PT _ (T_TokElse _)        }
  L_TokDot         { PT _ (T_TokDot _)         }
  L_TokElemOf      { PT _ (T_TokElemOf _)      }
  L_TokLambda      { PT _ (T_TokLambda _)      }
  L_TokTensor      { PT _ (T_TokTensor _)      }
  L_TokList        { PT _ (T_TokList _)        }
  L_TokReal        { PT _ (T_TokReal _)        }
  L_TokRat         { PT _ (T_TokRat _)         }
  L_TokInt         { PT _ (T_TokInt _)         }
  L_TokNat         { PT _ (T_TokNat _)         }
  L_TokBool        { PT _ (T_TokBool _)        }
  L_TokProp        { PT _ (T_TokProp _)        }
  L_TokForall      { PT _ (T_TokForall _)      }
  L_TokExists      { PT _ (T_TokExists _)      }
  L_TokImpl        { PT _ (T_TokImpl _)        }
  L_TokAnd         { PT _ (T_TokAnd _)         }
  L_TokOr          { PT _ (T_TokOr _)          }
  L_TokNot         { PT _ (T_TokNot _)         }
  L_TokEq          { PT _ (T_TokEq _)          }
  L_TokNeq         { PT _ (T_TokNeq _)         }
  L_TokLe          { PT _ (T_TokLe _)          }
  L_TokLt          { PT _ (T_TokLt _)          }
  L_TokGe          { PT _ (T_TokGe _)          }
  L_TokGt          { PT _ (T_TokGt _)          }
  L_TokMul         { PT _ (T_TokMul _)         }
  L_TokDiv         { PT _ (T_TokDiv _)         }
  L_TokAdd         { PT _ (T_TokAdd _)         }
  L_TokSub         { PT _ (T_TokSub _)         }
  L_TokSeqOpen     { PT _ (T_TokSeqOpen _)     }
  L_TokSeqClose    { PT _ (T_TokSeqClose _)    }
  L_TokCons        { PT _ (T_TokCons _)        }
  L_TokAt          { PT _ (T_TokAt _)          }
  L_TokMap         { PT _ (T_TokMap _)         }
  L_TokFold        { PT _ (T_TokFold _)        }
  L_TokTrue        { PT _ (T_TokTrue _)        }
  L_TokFalse       { PT _ (T_TokFalse _)       }
  L_TokTCEq        { PT _ (T_TokTCEq _)        }
  L_TokTCOrd       { PT _ (T_TokTCOrd _)       }
  L_TokTCContainer { PT _ (T_TokTCContainer _) }
  L_TokTCTruth     { PT _ (T_TokTCTruth _)     }
  L_TokTCQuantify  { PT _ (T_TokTCQuantify _)  }
  L_TokTCNatural   { PT _ (T_TokTCNatural _)   }
  L_TokTCIntegral  { PT _ (T_TokTCIntegral _)  }
  L_TokTCRational  { PT _ (T_TokTCRational _)  }
  L_TokTCReal      { PT _ (T_TokTCReal _)      }
  L_Name           { PT _ (T_Name _)           }
  L_HoleToken      { PT _ (T_HoleToken _)      }
  L_Rational       { PT _ (T_Rational _)       }

%%

Integer :: { Integer }
Integer  : L_integ  { (read (Data.Text.unpack $1)) :: Integer }

TokArrow :: { Vehicle.Frontend.Abs.TokArrow }
TokArrow  : L_TokArrow { Vehicle.Frontend.Abs.TokArrow (mkPosToken $1) }

TokForallT :: { Vehicle.Frontend.Abs.TokForallT }
TokForallT  : L_TokForallT { Vehicle.Frontend.Abs.TokForallT (mkPosToken $1) }

TokIf :: { Vehicle.Frontend.Abs.TokIf }
TokIf  : L_TokIf { Vehicle.Frontend.Abs.TokIf (mkPosToken $1) }

TokThen :: { Vehicle.Frontend.Abs.TokThen }
TokThen  : L_TokThen { Vehicle.Frontend.Abs.TokThen (mkPosToken $1) }

TokElse :: { Vehicle.Frontend.Abs.TokElse }
TokElse  : L_TokElse { Vehicle.Frontend.Abs.TokElse (mkPosToken $1) }

TokDot :: { Vehicle.Frontend.Abs.TokDot }
TokDot  : L_TokDot { Vehicle.Frontend.Abs.TokDot (mkPosToken $1) }

TokElemOf :: { Vehicle.Frontend.Abs.TokElemOf }
TokElemOf  : L_TokElemOf { Vehicle.Frontend.Abs.TokElemOf (mkPosToken $1) }

TokLambda :: { Vehicle.Frontend.Abs.TokLambda }
TokLambda  : L_TokLambda { Vehicle.Frontend.Abs.TokLambda (mkPosToken $1) }

TokTensor :: { Vehicle.Frontend.Abs.TokTensor }
TokTensor  : L_TokTensor { Vehicle.Frontend.Abs.TokTensor (mkPosToken $1) }

TokList :: { Vehicle.Frontend.Abs.TokList }
TokList  : L_TokList { Vehicle.Frontend.Abs.TokList (mkPosToken $1) }

TokReal :: { Vehicle.Frontend.Abs.TokReal }
TokReal  : L_TokReal { Vehicle.Frontend.Abs.TokReal (mkPosToken $1) }

TokRat :: { Vehicle.Frontend.Abs.TokRat }
TokRat  : L_TokRat { Vehicle.Frontend.Abs.TokRat (mkPosToken $1) }

TokInt :: { Vehicle.Frontend.Abs.TokInt }
TokInt  : L_TokInt { Vehicle.Frontend.Abs.TokInt (mkPosToken $1) }

TokNat :: { Vehicle.Frontend.Abs.TokNat }
TokNat  : L_TokNat { Vehicle.Frontend.Abs.TokNat (mkPosToken $1) }

TokBool :: { Vehicle.Frontend.Abs.TokBool }
TokBool  : L_TokBool { Vehicle.Frontend.Abs.TokBool (mkPosToken $1) }

TokProp :: { Vehicle.Frontend.Abs.TokProp }
TokProp  : L_TokProp { Vehicle.Frontend.Abs.TokProp (mkPosToken $1) }

TokForall :: { Vehicle.Frontend.Abs.TokForall }
TokForall  : L_TokForall { Vehicle.Frontend.Abs.TokForall (mkPosToken $1) }

TokExists :: { Vehicle.Frontend.Abs.TokExists }
TokExists  : L_TokExists { Vehicle.Frontend.Abs.TokExists (mkPosToken $1) }

TokImpl :: { Vehicle.Frontend.Abs.TokImpl }
TokImpl  : L_TokImpl { Vehicle.Frontend.Abs.TokImpl (mkPosToken $1) }

TokAnd :: { Vehicle.Frontend.Abs.TokAnd }
TokAnd  : L_TokAnd { Vehicle.Frontend.Abs.TokAnd (mkPosToken $1) }

TokOr :: { Vehicle.Frontend.Abs.TokOr }
TokOr  : L_TokOr { Vehicle.Frontend.Abs.TokOr (mkPosToken $1) }

TokNot :: { Vehicle.Frontend.Abs.TokNot }
TokNot  : L_TokNot { Vehicle.Frontend.Abs.TokNot (mkPosToken $1) }

TokEq :: { Vehicle.Frontend.Abs.TokEq }
TokEq  : L_TokEq { Vehicle.Frontend.Abs.TokEq (mkPosToken $1) }

TokNeq :: { Vehicle.Frontend.Abs.TokNeq }
TokNeq  : L_TokNeq { Vehicle.Frontend.Abs.TokNeq (mkPosToken $1) }

TokLe :: { Vehicle.Frontend.Abs.TokLe }
TokLe  : L_TokLe { Vehicle.Frontend.Abs.TokLe (mkPosToken $1) }

TokLt :: { Vehicle.Frontend.Abs.TokLt }
TokLt  : L_TokLt { Vehicle.Frontend.Abs.TokLt (mkPosToken $1) }

TokGe :: { Vehicle.Frontend.Abs.TokGe }
TokGe  : L_TokGe { Vehicle.Frontend.Abs.TokGe (mkPosToken $1) }

TokGt :: { Vehicle.Frontend.Abs.TokGt }
TokGt  : L_TokGt { Vehicle.Frontend.Abs.TokGt (mkPosToken $1) }

TokMul :: { Vehicle.Frontend.Abs.TokMul }
TokMul  : L_TokMul { Vehicle.Frontend.Abs.TokMul (mkPosToken $1) }

TokDiv :: { Vehicle.Frontend.Abs.TokDiv }
TokDiv  : L_TokDiv { Vehicle.Frontend.Abs.TokDiv (mkPosToken $1) }

TokAdd :: { Vehicle.Frontend.Abs.TokAdd }
TokAdd  : L_TokAdd { Vehicle.Frontend.Abs.TokAdd (mkPosToken $1) }

TokSub :: { Vehicle.Frontend.Abs.TokSub }
TokSub  : L_TokSub { Vehicle.Frontend.Abs.TokSub (mkPosToken $1) }

TokSeqOpen :: { Vehicle.Frontend.Abs.TokSeqOpen }
TokSeqOpen  : L_TokSeqOpen { Vehicle.Frontend.Abs.TokSeqOpen (mkPosToken $1) }

TokSeqClose :: { Vehicle.Frontend.Abs.TokSeqClose }
TokSeqClose  : L_TokSeqClose { Vehicle.Frontend.Abs.TokSeqClose (mkPosToken $1) }

TokCons :: { Vehicle.Frontend.Abs.TokCons }
TokCons  : L_TokCons { Vehicle.Frontend.Abs.TokCons (mkPosToken $1) }

TokAt :: { Vehicle.Frontend.Abs.TokAt }
TokAt  : L_TokAt { Vehicle.Frontend.Abs.TokAt (mkPosToken $1) }

TokMap :: { Vehicle.Frontend.Abs.TokMap }
TokMap  : L_TokMap { Vehicle.Frontend.Abs.TokMap (mkPosToken $1) }

TokFold :: { Vehicle.Frontend.Abs.TokFold }
TokFold  : L_TokFold { Vehicle.Frontend.Abs.TokFold (mkPosToken $1) }

TokTrue :: { Vehicle.Frontend.Abs.TokTrue }
TokTrue  : L_TokTrue { Vehicle.Frontend.Abs.TokTrue (mkPosToken $1) }

TokFalse :: { Vehicle.Frontend.Abs.TokFalse }
TokFalse  : L_TokFalse { Vehicle.Frontend.Abs.TokFalse (mkPosToken $1) }

TokTCEq :: { Vehicle.Frontend.Abs.TokTCEq }
TokTCEq  : L_TokTCEq { Vehicle.Frontend.Abs.TokTCEq (mkPosToken $1) }

TokTCOrd :: { Vehicle.Frontend.Abs.TokTCOrd }
TokTCOrd  : L_TokTCOrd { Vehicle.Frontend.Abs.TokTCOrd (mkPosToken $1) }

TokTCContainer :: { Vehicle.Frontend.Abs.TokTCContainer }
TokTCContainer  : L_TokTCContainer { Vehicle.Frontend.Abs.TokTCContainer (mkPosToken $1) }

TokTCTruth :: { Vehicle.Frontend.Abs.TokTCTruth }
TokTCTruth  : L_TokTCTruth { Vehicle.Frontend.Abs.TokTCTruth (mkPosToken $1) }

TokTCQuantify :: { Vehicle.Frontend.Abs.TokTCQuantify }
TokTCQuantify  : L_TokTCQuantify { Vehicle.Frontend.Abs.TokTCQuantify (mkPosToken $1) }

TokTCNatural :: { Vehicle.Frontend.Abs.TokTCNatural }
TokTCNatural  : L_TokTCNatural { Vehicle.Frontend.Abs.TokTCNatural (mkPosToken $1) }

TokTCIntegral :: { Vehicle.Frontend.Abs.TokTCIntegral }
TokTCIntegral  : L_TokTCIntegral { Vehicle.Frontend.Abs.TokTCIntegral (mkPosToken $1) }

TokTCRational :: { Vehicle.Frontend.Abs.TokTCRational }
TokTCRational  : L_TokTCRational { Vehicle.Frontend.Abs.TokTCRational (mkPosToken $1) }

TokTCReal :: { Vehicle.Frontend.Abs.TokTCReal }
TokTCReal  : L_TokTCReal { Vehicle.Frontend.Abs.TokTCReal (mkPosToken $1) }

Name :: { Vehicle.Frontend.Abs.Name }
Name  : L_Name { Vehicle.Frontend.Abs.Name (mkPosToken $1) }

HoleToken :: { Vehicle.Frontend.Abs.HoleToken }
HoleToken  : L_HoleToken { Vehicle.Frontend.Abs.HoleToken (mkPosToken $1) }

Rational :: { Vehicle.Frontend.Abs.Rational }
Rational  : L_Rational { Vehicle.Frontend.Abs.Rational (mkPosToken $1) }

ListName :: { [Vehicle.Frontend.Abs.Name] }
ListName : {- empty -} { [] } | Name ListName { (:) $1 $2 }

Binder :: { Vehicle.Frontend.Abs.Binder }
Binder
  : Name { Vehicle.Frontend.Abs.ExplicitBinder $1 }
  | '(' Name TokElemOf Expr1 ')' { Vehicle.Frontend.Abs.ExplicitBinderAnn $2 $3 $4 }
  | '{' Name '}' { Vehicle.Frontend.Abs.ImplicitBinder $2 }
  | '{' Name TokElemOf Expr1 '}' { Vehicle.Frontend.Abs.ImplicitBinderAnn $2 $3 $4 }
  | '{{' Name '}}' { Vehicle.Frontend.Abs.InstanceBinder $2 }
  | '{{' Name TokElemOf Expr1 '}}' { Vehicle.Frontend.Abs.InstanceBinderAnn $2 $3 $4 }

ListBinder :: { [Vehicle.Frontend.Abs.Binder] }
ListBinder : {- empty -} { [] } | Binder ListBinder { (:) $1 $2 }

Arg :: { Vehicle.Frontend.Abs.Arg }
Arg
  : Expr15 { Vehicle.Frontend.Abs.ExplicitArg $1 }
  | '{' Expr1 '}' { Vehicle.Frontend.Abs.ImplicitArg $2 }
  | '{{' Expr1 '}}' { Vehicle.Frontend.Abs.InstanceArg $2 }

LetDecl :: { Vehicle.Frontend.Abs.LetDecl }
LetDecl : Binder '=' Expr { Vehicle.Frontend.Abs.LDecl $1 $3 }

ListLetDecl :: { [Vehicle.Frontend.Abs.LetDecl] }
ListLetDecl
  : {- empty -} { [] }
  | LetDecl { (:[]) $1 }
  | LetDecl ',' ListLetDecl { (:) $1 $3 }

Lit :: { Vehicle.Frontend.Abs.Lit }
Lit
  : Integer { Vehicle.Frontend.Abs.LitInt $1 }
  | Rational { Vehicle.Frontend.Abs.LitRat $1 }
  | TokTrue { Vehicle.Frontend.Abs.LitTrue $1 }
  | TokFalse { Vehicle.Frontend.Abs.LitFalse $1 }

Expr15 :: { Vehicle.Frontend.Abs.Expr }
Expr15
  : 'Type' Integer { Vehicle.Frontend.Abs.Type $2 }
  | Name { Vehicle.Frontend.Abs.Var $1 }
  | Lit { Vehicle.Frontend.Abs.Literal $1 }
  | HoleToken { Vehicle.Frontend.Abs.Hole $1 }
  | TokBool { Vehicle.Frontend.Abs.Bool $1 }
  | TokProp { Vehicle.Frontend.Abs.Prop $1 }
  | TokReal { Vehicle.Frontend.Abs.Real $1 }
  | TokRat { Vehicle.Frontend.Abs.Rat $1 }
  | TokInt { Vehicle.Frontend.Abs.Int $1 }
  | TokNat { Vehicle.Frontend.Abs.Nat $1 }
  | TokSeqOpen ListExpr TokSeqClose { Vehicle.Frontend.Abs.LSeq $1 $2 $3 }
  | TokTCEq Expr15 Expr15 { Vehicle.Frontend.Abs.TCEq $1 $2 $3 }
  | TokTCOrd Expr15 Expr15 { Vehicle.Frontend.Abs.TCOrd $1 $2 $3 }
  | TokTCContainer Expr15 Expr15 { Vehicle.Frontend.Abs.TCCont $1 $2 $3 }
  | TokTCTruth Expr15 { Vehicle.Frontend.Abs.TCTruth $1 $2 }
  | TokTCQuantify Expr15 { Vehicle.Frontend.Abs.TCQuant $1 $2 }
  | TokTCNatural Expr15 { Vehicle.Frontend.Abs.TCNat $1 $2 }
  | TokTCIntegral Expr15 { Vehicle.Frontend.Abs.TCInt $1 $2 }
  | TokTCRational Expr15 { Vehicle.Frontend.Abs.TCRat $1 $2 }
  | TokTCReal Expr15 { Vehicle.Frontend.Abs.TCReal $1 $2 }
  | '(' Expr ')' { $2 }

Expr :: { Vehicle.Frontend.Abs.Expr }
Expr
  : Expr2 TokElemOf Expr1 { Vehicle.Frontend.Abs.Ann $1 $2 $3 }
  | Expr1 { $1 }

Expr1 :: { Vehicle.Frontend.Abs.Expr }
Expr1
  : TokForallT ListBinder TokDot Expr1 { Vehicle.Frontend.Abs.ForallT $1 $2 $3 $4 }
  | Expr2 { $1 }

Expr2 :: { Vehicle.Frontend.Abs.Expr }
Expr2
  : 'let' '{' ListLetDecl '}' 'in' Expr2 { Vehicle.Frontend.Abs.Let $3 $6 }
  | TokIf Expr3 TokThen Expr3 TokElse Expr3 { Vehicle.Frontend.Abs.If $1 $2 $3 $4 $5 $6 }
  | Expr3 { $1 }

Expr3 :: { Vehicle.Frontend.Abs.Expr }
Expr3
  : TokLambda ListBinder TokArrow Expr3 { Vehicle.Frontend.Abs.Lam $1 $2 $3 $4 }
  | Expr4 { $1 }

Expr13 :: { Vehicle.Frontend.Abs.Expr }
Expr13
  : Expr13 Arg { Vehicle.Frontend.Abs.App $1 $2 }
  | TokMap Expr15 Expr15 { Vehicle.Frontend.Abs.Map $1 $2 $3 }
  | TokFold Expr15 Expr15 Expr15 { Vehicle.Frontend.Abs.Fold $1 $2 $3 $4 }
  | Expr14 { $1 }

Expr11 :: { Vehicle.Frontend.Abs.Expr }
Expr11
  : Expr13 TokArrow Expr11 { Vehicle.Frontend.Abs.Fun $1 $2 $3 }
  | TokNot Expr11 { Vehicle.Frontend.Abs.Not $1 $2 }
  | TokSub Expr11 { Vehicle.Frontend.Abs.Neg $1 $2 }
  | Expr12 { $1 }

Expr14 :: { Vehicle.Frontend.Abs.Expr }
Expr14
  : TokList Expr15 { Vehicle.Frontend.Abs.List $1 $2 }
  | TokTensor Expr15 Expr15 { Vehicle.Frontend.Abs.Tensor $1 $2 $3 }
  | Expr15 { $1 }

Expr5 :: { Vehicle.Frontend.Abs.Expr }
Expr5
  : Expr6 TokImpl Expr5 { Vehicle.Frontend.Abs.Impl $1 $2 $3 }
  | Expr6 { $1 }

Expr6 :: { Vehicle.Frontend.Abs.Expr }
Expr6
  : Expr7 TokAnd Expr6 { Vehicle.Frontend.Abs.And $1 $2 $3 }
  | Expr7 { $1 }

Expr7 :: { Vehicle.Frontend.Abs.Expr }
Expr7
  : Expr8 TokOr Expr7 { Vehicle.Frontend.Abs.Or $1 $2 $3 }
  | Expr8 { $1 }

Expr8 :: { Vehicle.Frontend.Abs.Expr }
Expr8
  : Expr9 TokEq Expr9 { Vehicle.Frontend.Abs.Eq $1 $2 $3 }
  | Expr9 TokNeq Expr9 { Vehicle.Frontend.Abs.Neq $1 $2 $3 }
  | Expr8 TokLe Expr9 { Vehicle.Frontend.Abs.Le $1 $2 $3 }
  | Expr8 TokLt Expr9 { Vehicle.Frontend.Abs.Lt $1 $2 $3 }
  | Expr8 TokGe Expr9 { Vehicle.Frontend.Abs.Ge $1 $2 $3 }
  | Expr8 TokGt Expr9 { Vehicle.Frontend.Abs.Gt $1 $2 $3 }
  | Expr9 { $1 }

Expr9 :: { Vehicle.Frontend.Abs.Expr }
Expr9
  : Expr9 TokAdd Expr10 { Vehicle.Frontend.Abs.Add $1 $2 $3 }
  | Expr9 TokSub Expr10 { Vehicle.Frontend.Abs.Sub $1 $2 $3 }
  | Expr10 { $1 }

Expr10 :: { Vehicle.Frontend.Abs.Expr }
Expr10
  : Expr10 TokMul Expr11 { Vehicle.Frontend.Abs.Mul $1 $2 $3 }
  | Expr10 TokDiv Expr11 { Vehicle.Frontend.Abs.Div $1 $2 $3 }
  | Expr11 { $1 }

Expr4 :: { Vehicle.Frontend.Abs.Expr }
Expr4
  : Expr5 TokCons Expr4 { Vehicle.Frontend.Abs.Cons $1 $2 $3 }
  | TokForall ListBinder TokDot Expr5 { Vehicle.Frontend.Abs.Forall $1 $2 $3 $4 }
  | TokExists ListBinder TokDot Expr5 { Vehicle.Frontend.Abs.Exists $1 $2 $3 $4 }
  | TokForall ListBinder 'inn' Expr5 TokDot Expr5 { Vehicle.Frontend.Abs.ForallIn $1 $2 $4 $5 $6 }
  | TokExists ListBinder 'inn' Expr5 TokDot Expr5 { Vehicle.Frontend.Abs.ExistsIn $1 $2 $4 $5 $6 }
  | Expr5 { $1 }

Expr12 :: { Vehicle.Frontend.Abs.Expr }
Expr12
  : Expr12 TokAt Expr13 { Vehicle.Frontend.Abs.At $1 $2 $3 }
  | Expr13 { $1 }

ListExpr :: { [Vehicle.Frontend.Abs.Expr] }
ListExpr
  : {- empty -} { [] }
  | Expr { (:[]) $1 }
  | Expr ',' ListExpr { (:) $1 $3 }

Decl :: { Vehicle.Frontend.Abs.Decl }
Decl
  : 'network' Name TokElemOf Expr { Vehicle.Frontend.Abs.DeclNetw $2 $3 $4 }
  | 'dataset' Name TokElemOf Expr { Vehicle.Frontend.Abs.DeclData $2 $3 $4 }
  | 'type' Name ListBinder '=' Expr { Vehicle.Frontend.Abs.DefType $2 $3 $5 }
  | Name TokElemOf Expr { Vehicle.Frontend.Abs.DefFunType $1 $2 $3 }
  | Name ListBinder '=' Expr { Vehicle.Frontend.Abs.DefFunExpr $1 $2 $4 }

ListDecl :: { [Vehicle.Frontend.Abs.Decl] }
ListDecl
  : {- empty -} { [] }
  | Decl { (:[]) $1 }
  | Decl ';' ListDecl { (:) $1 $3 }

Prog :: { Vehicle.Frontend.Abs.Prog }
Prog : ListDecl { Vehicle.Frontend.Abs.Main $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

}

