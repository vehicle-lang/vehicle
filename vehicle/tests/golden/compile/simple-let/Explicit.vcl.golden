mapList : (Nat -> Bool) -> List Nat -> List Bool;
mapList f = fold (\ x -> \ xs -> f x :: xs) nil

bigAnd : List Bool -> Bool;
bigAnd = fold (\ x -> \ y -> x and y) True

forallIn : (Nat -> Bool) -> List Nat -> Bool;
forallIn f xs = bigAnd (mapList f xs)

@property;
e1 : Bool;
e1 = let x = True in let y = False in x and y

@property;
e2 : Bool;
e2 = let y = 1 in y >= 2

e3 : Nat;
e3 = let y = 1 + 1 in y

lamLet : Nat -> Nat;
lamLet = \ (x : Nat) -> let y = x in y

letLam : Nat -> Nat;
letLam = let y = \ x -> x in y

@property;
forallLet : Bool;
forallLet = forall (x : Nat) . let y = x in y == 1

@property;
letForall : Bool;
letForall = let y = 1 in forall (x : Nat) . y == x

@property;
forallInLet : Bool;
forallInLet = forallIn (\ x -> let y = x in y == 1) (1 :: nil)

@property;
letForallIn : Bool;
letForallIn = let y = 1 in forallIn (\ x -> y == x) (1 :: nil)

falsey : Rat -> Bool;
falsey x = x <= 0.5

@property;
correctOutput : Bool;
correctOutput = let y = 0.0 in falsey y