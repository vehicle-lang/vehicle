bigAnd : (\ A -> Vector A) Loss -> Loss;
bigAnd _x0 = fold (\ x -> \ y -> x + y) 0.0 _x0

foreachVector : forallT n . (Index -> Loss) -> Vector Loss;
foreachVector n f = map f (indices n)

forallIndex : forallT n . (Index -> Loss) -> Loss;
forallIndex n f = bigAnd (foreachVector n (\ i -> f i))

type Tensor A ds = fold (\ d -> \ t -> Vector t) A ds

type InputVector = Tensor Rat (2 :: nil)

currentSensor : Index;
currentSensor = 0

previousSensor : Index;
previousSensor = 1

safeInput : InputVector -> Loss;
safeInput x = forallIndex 2 (\ i -> max 0.0 (- 3.25 - x ! i) + (if - 3.25 == x ! i then 1.0 else 0.0) + (max 0.0 (x ! i - 3.25) + (if x ! i == 3.25 then 1.0 else 0.0)))

safeOutput : forallT (controller : InputVector -> Tensor Rat (1 :: nil)) . InputVector -> Loss;
safeOutput controller x = max 0.0 (- 1.25 - (controller x ! 0 + 2.0 * x ! currentSensor - x ! previousSensor)) + max 0.0 (controller x ! 0 + 2.0 * x ! currentSensor - x ! previousSensor - 1.25)

@property;
safe : forallT (controller : InputVector -> Tensor Rat (1 :: nil)) . Loss;
safe controller = Optimise[min] (+) (\ x -> max 0.0 (safeInput x * safeOutput controller x))