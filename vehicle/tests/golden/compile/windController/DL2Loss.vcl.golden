<<<<<<< HEAD
mapList : (Vector Rat 2 -> Rat) -> List (Vector Rat 2) -> List Rat;
mapList f _x0 = fold (\ x -> \ xs -> f x :: xs) nil _x0

bigAnd__lam_A__Vector_A_2 : (\ A -> Vector A 2) Rat -> Rat;
bigAnd__lam_A__Vector_A_2 _x0 = (\ {A} -> \ {B} -> \ f -> dfold (\ {m} -> f)) (\ x -> \ y -> x + y) 0.0 _x0

bigAnd__List : List Rat -> Rat;
bigAnd__List _x0 = fold (\ x -> \ y -> x + y) 0.0 _x0

mapVector : (Index 2 -> Rat) -> Vector (Index 2) 2 -> Vector Rat 2;
mapVector f _x0 = dfold {Index 2} {2} {Vector Rat} (\ {l} -> \ x -> \ xs -> f x :: xs) [] _x0
=======
bigAnd : (\ A -> Vector A) Rat -> Rat;
bigAnd = (\ {A} -> \ {B} -> \ f -> dfold f) (\ x -> \ y -> x + y) 0.0

vectorToVector : Vector Rat -> Vector Rat;
vectorToVector xs = xs

mapVector : (Index -> Rat) -> Vector (Index) -> Vector Rat;
mapVector f = dfold {Index} {Vector Rat} (\ x -> \ xs -> f x :: xs) []
>>>>>>> size-irrelevancy

foreachVector : forallT n . (Index -> Rat) -> Vector Rat;
foreachVector n f = mapVector f (indices n)

<<<<<<< HEAD
forallIndex : (Index 2 -> Rat) -> Rat;
forallIndex f = bigAnd__lam_A__Vector_A_2 (foreachVector (\ i -> f i))
=======
forallIndex : forallT n . (Index -> Rat) -> Rat;
forallIndex n f = bigAnd (foreachVector n (\ i -> f i))
>>>>>>> size-irrelevancy

type Tensor A ds = fold (\ d -> \ t -> Vector t) A ds

<<<<<<< HEAD
=======
vectorToList : Vector Nat -> List Nat;
vectorToList = (\ {A} -> \ {B} -> \ f -> dfold f) (\ x -> \ xs -> x :: xs) nil

mapList : (Vector Rat -> Rat) -> List (Vector Rat) -> List Rat;
mapList f = fold (\ x -> \ xs -> f x :: xs) nil

>>>>>>> size-irrelevancy
type InputVector = Tensor Rat (2 :: nil)

currentSensor : Index;
currentSensor = 0

previousSensor : Index;
previousSensor = 1

safeInput : InputVector -> Rat;
safeInput x = forallIndex 2 (\ i -> max 0.0 (- 3.25 - x ! i) + max 0.0 (x ! i - 3.25))

safeOutput : forallT (controller : InputVector -> Tensor Rat (1 :: nil)) . InputVector -> Rat;
safeOutput controller x = max 0.0 (- 1.25 - (controller x ! 0 + 2.0 * x ! currentSensor - x ! previousSensor)) + (if - 1.25 == controller x ! 0 + 2.0 * x ! currentSensor - x ! previousSensor then 1.0 else 0.0) + (max 0.0 (controller x ! 0 + 2.0 * x ! currentSensor - x ! previousSensor - 1.25) + (if controller x ! 0 + 2.0 * x ! currentSensor - x ! previousSensor == 1.25 then 1.0 else 0.0))

@property;
safe : forallT (controller : InputVector -> Tensor Rat (1 :: nil)) . Rat;
safe controller = bigAnd__List (mapList (\ x -> max 0.0 (safeInput x * safeOutput controller x)) sample[x][])