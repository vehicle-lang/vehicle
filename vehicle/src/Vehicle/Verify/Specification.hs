module Vehicle.Verify.Specification
  ( QueryMetaData (..),
    QueryText,
    isNonTrivial,
    QueryID,
    QuerySet (..),
    Property,
    traverseProperty,
    propertySize,
    MultiProperty (..),
    traverseMultiProperty,
    Specification (..),
    traverseSpecification,
    specificationPropertyNames,
    VerificationPlan (..),
    VerificationQueries,
  )
where

import Data.Aeson (FromJSON, ToJSON)
import GHC.Generics (Generic)
import Vehicle.Expr.Boolean
import Vehicle.Prelude
import Vehicle.Resource
import Vehicle.Syntax.AST (Name)
import Vehicle.Verify.Core

--------------------------------------------------------------------------------
-- Query meta data

data QueryMetaData = QueryData
  { metaNetwork :: MetaNetwork,
    variableReconstruction :: VariableNormalisationSteps
  }
  deriving (Show, Generic)

instance ToJSON QueryMetaData

instance FromJSON QueryMetaData

instance Pretty QueryMetaData where
  pretty (QueryData metaNetwork _userVar) =
    "Meta-network:" <+> pretty metaNetwork

--------------------------------------------------------------------------------
-- Query set

data QuerySet a = QuerySet
  { negated :: QuerySetNegationStatus,
    queries :: MaybeTrivial (DisjunctAll (QueryAddress, a))
  }
  deriving (Show, Generic, Functor, Foldable, Traversable)

instance (ToJSON a) => ToJSON (QuerySet a)

instance (FromJSON a) => FromJSON (QuerySet a)

traverseQuerySet ::
  (Monad m) =>
  ((QueryAddress, a) -> m b) ->
  QuerySet a ->
  m (QuerySet b)
traverseQuerySet f QuerySet {..} = do
  queries' <- traverse (traverse (\(address, query) -> (address,) <$> f (address, query))) queries
  return $ QuerySet negated queries'

querySetSize :: QuerySet a -> Int
querySetSize QuerySet {..} = case queries of
  Trivial {} -> 0
  NonTrivial qs -> length qs

--------------------------------------------------------------------------------
-- Property expression

-- | Properties may have arbitrary boolean structure above queries.
--
-- e.g. (forall ....) or (exists (...) and (forall ...)).
--
-- This type captures this boolean structure, and is parameterised by the type
-- of data stored at the position of each query.
type Property a = BooleanExpr (QuerySet a)

traverseProperty ::
  (Monad m) =>
  ((QueryAddress, a) -> m b) ->
  Property a ->
  m (Property b)
traverseProperty f = \case
  Query qs -> Query <$> traverseQuerySet f qs
  Disjunct x y -> Disjunct <$> traverseProperty f x <*> traverseProperty f y
  Conjunct x y -> Conjunct <$> traverseProperty f x <*> traverseProperty f y

propertySize :: Property a -> Int
propertySize p = sum (fmap querySetSize p)

--------------------------------------------------------------------------------
-- MultiProperty

data MultiProperty property
  = -- | A single boolean property.
    SingleProperty PropertyAddress property
  | -- | Multiple nested boolean properties e.g. generated by a `foreach`.
    -- They are implicitly conjuncted.
    MultiProperty [MultiProperty property]
  deriving (Show, Functor, Generic)

instance (ToJSON property) => ToJSON (MultiProperty property)

instance (FromJSON property) => FromJSON (MultiProperty property)

traverseMultiProperty ::
  (Monad m) =>
  ((QueryAddress, a) -> m b) ->
  MultiProperty (Property a) ->
  m (MultiProperty (Property b))
traverseMultiProperty f = \case
  SingleProperty indices p -> SingleProperty indices <$> traverseProperty f p
  MultiProperty ps -> MultiProperty <$> traverse (traverseMultiProperty f) ps

--------------------------------------------------------------------------------
-- Specification

-- | A compiled specification, parameterised by the data stored at each query.
newtype Specification property
  = Specification [(Name, MultiProperty property)]
  deriving (Show, Generic, Functor)

instance (ToJSON property) => ToJSON (Specification property)

instance (FromJSON property) => FromJSON (Specification property)

specificationPropertyNames :: Specification a -> PropertyNames
specificationPropertyNames (Specification properties) = fmap fst properties

traverseSpecification ::
  (Monad m) =>
  ((QueryAddress, a) -> m b) ->
  Specification (Property a) ->
  m (Specification (Property b))
traverseSpecification f (Specification properties) =
  Specification <$> traverse (\(n, q) -> (n,) <$> traverseMultiProperty f q) properties

--------------------------------------------------------------------------------
-- VerificationPlan

data VerificationPlan = VerificationPlan
  { specificationPlan :: Specification (Property QueryMetaData),
    resourceIntegrityInfo :: ResourcesIntegrityInfo
  }
  deriving (Generic)

instance ToJSON VerificationPlan

instance FromJSON VerificationPlan

type VerificationQueries = Specification (Property QueryText)
