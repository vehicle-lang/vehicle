module Vehicle.Verify.Specification
  ( QueryMetaData (..),
    QueryText,
    isNonTrivial,
    QueryID,
    QuerySet (..),
    Property,
    traverseProperty,
    MultiProperty (..),
    traverseMultiProperty,
    Specification (..),
    traverseSpecification,
    specificationPropertyNames,
    VerificationPlan (..),
    VerificationQueries,
    MetaNetwork,
  )
where

import Data.Aeson (FromJSON, ToJSON)
import GHC.Generics (Generic)
import Vehicle.Expr.Boolean
import Vehicle.Prelude
import Vehicle.Resource
import Vehicle.Syntax.AST (Name)
import Vehicle.Verify.Core

--------------------------------------------------------------------------------
-- Query meta data

data QueryMetaData = QueryData
  { metaNetwork :: MetaNetwork,
    variableInfo :: QueryVariableInfo
  }
  deriving (Show, Generic)

instance ToJSON QueryMetaData

instance FromJSON QueryMetaData

instance Pretty QueryMetaData where
  pretty (QueryData metaNetwork _userVar) =
    "Meta-network:" <+> pretty metaNetwork

--------------------------------------------------------------------------------
-- Query set

data QuerySet a = QuerySet
  { negated :: QueryNegationStatus,
    queries :: MaybeTrivial (DisjunctAll (QueryAddress, a))
  }
  deriving (Show, Generic, Functor, Foldable, Traversable)

instance ToJSON a => ToJSON (QuerySet a)

instance FromJSON a => FromJSON (QuerySet a)

traverseQuerySet ::
  Monad m =>
  ((QueryAddress, a) -> m b) ->
  QuerySet a ->
  m (QuerySet b)
traverseQuerySet f QuerySet {..} = do
  queries' <- traverse (traverse (\(address, query) -> (address,) <$> f (address, query))) queries
  return $ QuerySet negated queries'

--------------------------------------------------------------------------------
-- Property expression

-- | Properties may have arbitrary boolean structure above queries.
--
-- e.g. (forall ....) or (exists (...) and (forall ...)).
--
-- This type captures this boolean structure, and is parameterised by the type
-- of data stored at the position of each query.
type Property a = BooleanExpr (QuerySet a)

traverseProperty ::
  Monad m =>
  ((QueryAddress, a) -> m b) ->
  Property a ->
  m (Property b)
traverseProperty f = \case
  Query qs -> Query <$> traverseQuerySet f qs
  Disjunct x y -> Disjunct <$> traverseProperty f x <*> traverseProperty f y
  Conjunct x y -> Conjunct <$> traverseProperty f x <*> traverseProperty f y

--------------------------------------------------------------------------------
-- MultiProperty

data MultiProperty queryData
  = -- | A single boolean property.
    SingleProperty PropertyAddress (Property queryData)
  | -- | Multiple nested boolean properties e.g. generated by a `foreach`.
    -- They are implicitly conjuncted.
    MultiProperty [MultiProperty queryData]
  deriving (Show, Functor, Generic)

instance ToJSON queryData => ToJSON (MultiProperty queryData)

instance FromJSON queryData => FromJSON (MultiProperty queryData)

traverseMultiProperty ::
  Monad m =>
  ((QueryAddress, a) -> m b) ->
  MultiProperty a ->
  m (MultiProperty b)
traverseMultiProperty f = \case
  SingleProperty indices p -> SingleProperty indices <$> traverseProperty f p
  MultiProperty ps -> MultiProperty <$> traverse (traverseMultiProperty f) ps

--------------------------------------------------------------------------------
-- Specification

-- | A compiled specification, parameterised by the data stored at each query.
newtype Specification queryData
  = Specification [(Name, MultiProperty queryData)]
  deriving (Show, Generic, Functor)

instance ToJSON queryData => ToJSON (Specification queryData)

instance FromJSON queryData => FromJSON (Specification queryData)

specificationPropertyNames :: Specification a -> PropertyNames
specificationPropertyNames (Specification properties) = fmap fst properties

traverseSpecification ::
  Monad m =>
  ((QueryAddress, a) -> m b) ->
  Specification a ->
  m (Specification b)
traverseSpecification f (Specification properties) =
  Specification <$> traverse (\(n, q) -> (n,) <$> traverseMultiProperty f q) properties

data VerificationPlan = VerificationPlan
  { specificationPlan :: Specification QueryMetaData,
    resourceIntegrityInfo :: ResourcesIntegrityInfo
  }
  deriving (Generic)

instance ToJSON VerificationPlan

instance FromJSON VerificationPlan

type VerificationQueries = Specification QueryText
