module Vehicle.Compile.Queries.FourierMotzkinElimination
  ( FourierMotzkinVariableSolution,
    fourierMotzkinElimination,
    reconstructFourierMotzkinVariableValue,
  )
where

import Control.Monad (foldM)
import Data.Set (Set)
import Data.Set qualified as Set (toList)
import Vehicle.Compile.Error
import Vehicle.Compile.Prelude
import Vehicle.Compile.Queries.LinearExpr
import Vehicle.Compile.Queries.Variable
import Vehicle.Verify.Core

-- | TODO If performance proves unnacceptably poor look into
-- Imbert's acceleration theorems:
--
-- Jean-Louis Imbert,
-- About Redundant Inequalities Generated by Fourier's Algorithm
-- Artificial Intelligence IV: Methodology, Systems, Applications, 1990
fourierMotzkinElimination ::
  (MonadCompile m, LinearExpression linexp) =>
  [Variable] ->
  Set LinearVar ->
  [Assertion linexp] ->
  m ([Solution], [Assertion linexp])
fourierMotzkinElimination varNames varsToSolve assertions =
  logCompilerPass MinDetail currentPass $ do
    logDebug MaxDetail $ prettyAssertions varNames assertions
    let numberedVars = zip [1 ..] (Set.toList varsToSolve)
    foldM (solveVar varNames) ([], assertions) numberedVars

type Solution = (LinearVar, FourierMotzkinVariableSolution)

solveVar ::
  (MonadCompile m, LinearExpression linexp) =>
  [Variable] ->
  ([Solution], [Assertion linexp]) ->
  (Int, LinearVar) ->
  m ([Solution], [Assertion linexp])
solveVar varNames (solutions, inequalities) (iteration, var) = do
  let (less, greater, unusedInequalities) = partition var inequalities
  let solution = (var, FMSolution (fmap (fmap toSparse) less) (fmap (fmap toSparse) greater))

  let newInequalities = fmap combineInequalities [(x, y) | x <- less, y <- greater]

  let varDoc = pretty $ varNames !! var
  logDebug MaxDetail $
    line <> "After iteration"
      <+> pretty iteration
      <+> "solving for"
      <+> varDoc
        <> ":"
        <> line
        <> indent
          2
          ( "LHS inequalities:"
              <> prettyAssertions varNames less
              <> line
              <> "RHS inequalities:"
              <> prettyAssertions varNames greater
              <> line
              <> "New inequalities:"
              <> prettyAssertions varNames newInequalities
          )

  return (solution : solutions, newInequalities <> unusedInequalities)

combineInequalities :: LinearExpression linexp => (Assertion linexp, Assertion linexp) -> Assertion linexp
combineInequalities (Assertion rel1 expr1, Assertion rel2 expr2) =
  let rel = case (rel1, rel2) of
        (LessThan, _) -> LessThan
        (_, LessThan) -> LessThan
        (_, _) -> LessThanOrEqualTo
   in Assertion
        { assertionExpr = addExprs 1 expr1 1 expr2,
          assertionRel = rel
        }

-- | Partitions the inequalities into three sets:
--  1. Those where the rest of the expression is less than the variable
--  2. Those where the rest of the expression is greater than the variable
--  3. Those which don't mention the variable at all.
partition ::
  forall linexp.
  LinearExpression linexp =>
  LinearVar ->
  [Assertion linexp] ->
  ([Assertion linexp], [Assertion linexp], [Assertion linexp])
partition var = foldr categorise ([], [], [])
  where
    categorise ::
      Assertion linexp ->
      ([Assertion linexp], [Assertion linexp], [Assertion linexp]) ->
      ([Assertion linexp], [Assertion linexp], [Assertion linexp])
    categorise a@(Assertion rel expr) (less, greater, unused) = do
      let coeff = lookupAt expr var
      if coeff < 0
        then do
          let coeff' = -coeff
          let expr' = scale (1 / coeff') expr
          let a' = Assertion rel expr'
          (a' : less, greater, unused)
        else
          if coeff > 0
            then do
              let expr' = scale (1 / coeff) expr
              let a' = Assertion rel expr'
              (less, a' : greater, unused)
            else (less, greater, a : unused)

--------------------------------------------------------------------------------
-- Solutions

-- | Tries to reconstruct the value of the variable that is
-- consistent with the current assignment of variables.
reconstructFourierMotzkinVariableValue ::
  VariableAssignment ->
  FourierMotzkinVariableSolution ->
  Double
reconstructFourierMotzkinVariableValue assignment solution = do
  let initialMax = (-1 / 0, LessThanOrEqualTo)
  let initialMin = (1 / 0, LessThanOrEqualTo)
  let (lowerBound, minRel) = foldr evaluateMaxValue initialMax (lowerBounds solution)
  let (upperBound, maxRel) = foldr evaluateMinValue initialMin (upperBounds solution)

  if lowerBound < upperBound || minRel == LessThanOrEqualTo && maxRel == LessThanOrEqualTo
    then (lowerBound + upperBound) / 2
    else -- Only 99% sure about this. Can't find a good reference to the reconstruction phase of the
    -- algorithm. Closest to referencing this impossibility is:
    -- https://people.math.carleton.ca/~kcheung/math/notes/MATH5801/02/2_1_fourier_motzkin.html
      developerError "Fourier-Motzkin reconstruction failed. This isn't supposed to be possible..."
  where
    evaluateMinValue :: Assertion SparseLinearExpr -> (Double, Relation) -> (Double, Relation)
    evaluateMinValue (Assertion rel expr) current@(currentMin, _) =
      let value = evaluateExpr expr assignment
       in if (value < currentMin) || (value == currentMin && rel == LessThan)
            then (value, rel)
            else current

    evaluateMaxValue :: Assertion SparseLinearExpr -> (Double, Relation) -> (Double, Relation)
    evaluateMaxValue (Assertion rel expr) current@(currentMax, _) =
      let value = evaluateExpr expr assignment
       in if (value > currentMax) || (value == currentMax && rel == LessThan)
            then (value, rel)
            else current

currentPass :: Doc a
currentPass = "Fourier-Motzkin elimination"
