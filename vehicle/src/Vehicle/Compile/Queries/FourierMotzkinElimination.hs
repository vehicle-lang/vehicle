module Vehicle.Compile.Queries.FourierMotzkinElimination
  ( FourierMotzkinVariableSolution,
    fourierMotzkinElimination,
    reconstructFourierMotzkinVariableValue,
  )
where

import Control.Monad (foldM)
import Data.Set (Set)
import Data.Set qualified as Set (toList)
import Data.Vector.Unboxed qualified as Vector
import Vehicle.Compile.Error
import Vehicle.Compile.Prelude
import Vehicle.Compile.Queries.LinearExpr
import Vehicle.Compile.Queries.Variable
import Vehicle.Verify.Core

-- | TODO If performance proves unnacceptably poor look into
-- Imbert's acceleration theorems:
--
-- Jean-Louis Imbert,
-- About Redundant Inequalities Generated by Fourier's Algorithm
-- Artificial Intelligence IV: Methodology, Systems, Applications, 1990
fourierMotzkinElimination ::
  (MonadCompile m) =>
  Set MixedVariable ->
  [FMAssertion] ->
  m ([Solution], [FMAssertion])
fourierMotzkinElimination varsToSolve assertions =
  logCompilerPass MidDetail currentPass $ do
    logDebug MaxDetail $ prettyAssertions assertions
    let numberedVars = zip [1 ..] (Set.toList varsToSolve)
    foldM solveVar ([], assertions) numberedVars

type FMAssertion = Assertion MixedVariable

type Solution = (MixedVariable, FourierMotzkinVariableSolution)

solveVar ::
  (MonadCompile m) =>
  ([Solution], [FMAssertion]) ->
  (Int, MixedVariable) ->
  m ([Solution], [FMAssertion])
solveVar (solutions, inequalities) (iteration, var) = do
  let (less, greater, unusedInequalities) = partition var inequalities
  let solution = (var, FMSolution less greater)

  let newInequalities = fmap combineInequalities [(x, y) | x <- less, y <- greater]

  logDebug MaxDetail $
    line
      <> "After iteration"
        <+> pretty iteration
        <+> "solving for"
        <+> pretty var
      <> ":"
      <> line
      <> indent
        2
        ( "LHS inequalities:"
            <> prettyAssertions less
            <> line
            <> "RHS inequalities:"
            <> prettyAssertions greater
            <> line
            <> "New inequalities:"
            <> prettyAssertions newInequalities
        )

  return (solution : solutions, newInequalities <> unusedInequalities)

combineInequalities :: (FMAssertion, FMAssertion) -> FMAssertion
combineInequalities (Assertion rel1 expr1, Assertion rel2 expr2) =
  let rel = case (rel1, rel2) of
        (LessThan, _) -> LessThan
        (_, LessThan) -> LessThan
        (_, _) -> LessThanOrEqualTo
   in Assertion
        { assertionExpr = addExprs 1 expr1 1 expr2,
          assertionRel = rel
        }

-- | Partitions the inequalities into three sets:
--  1. Those where the rest of the expression is less than the variable
--  2. Those where the rest of the expression is greater than the variable
--  3. Those which don't mention the variable at all.
partition ::
  MixedVariable ->
  [FMAssertion] ->
  ([FMAssertion], [FMAssertion], [FMAssertion])
partition var = foldr categorise ([], [], [])
  where
    categorise ::
      FMAssertion ->
      ([FMAssertion], [FMAssertion], [FMAssertion]) ->
      ([FMAssertion], [FMAssertion], [FMAssertion])
    categorise a@(Assertion rel expr) (less, greater, unused) = do
      let coeff = lookupCoefficient expr var
      if coeff < 0
        then do
          let coeff' = -coeff
          let expr' = scaleExpr (1 / coeff') expr
          let a' = Assertion rel expr'
          (a' : less, greater, unused)
        else
          if coeff > 0
            then do
              let expr' = scaleExpr (1 / coeff) expr
              let a' = Assertion rel expr'
              (less, a' : greater, unused)
            else (less, greater, a : unused)

--------------------------------------------------------------------------------
-- Solutions

-- | Tries to reconstruct the value of the variable that is
-- consistent with the current assignment of variables. Returns either a
-- required variable that is missing from the assignment or the reconstructed
-- value.
reconstructFourierMotzkinVariableValue ::
  VariableAssignment MixedVariable ->
  FourierMotzkinVariableSolution ->
  Either MixedVariable VariableValue
reconstructFourierMotzkinVariableValue assignment solution = do
  let size = 1
  let inf = 1 / 0
  let negInf = -1 / 0
  let initialMax = (Vector.replicate size negInf, LessThanOrEqualTo)
  let initialMin = (Vector.replicate size inf, LessThanOrEqualTo)
  (lowerBound, minRel) <- foldM evaluateMaxValue initialMax (lowerBounds solution)
  (upperBound, maxRel) <- foldM evaluateMinValue initialMin (upperBounds solution)

  if lowerBound < upperBound || minRel == LessThanOrEqualTo && maxRel == LessThanOrEqualTo
    then return $ addConstants 0.5 lowerBound 0.5 upperBound
    else -- Only 99% sure about this. Can't find a good reference to the reconstruction phase of the
    -- algorithm. Closest to referencing this impossibility is:
    -- https://people.math.carleton.ca/~kcheung/math/notes/MATH5801/02/2_1_fourier_motzkin.html
      developerError "Fourier-Motzkin reconstruction failed. This isn't supposed to be possible..."
  where
    evaluateMinValue ::
      (Constant, Relation) ->
      FMAssertion ->
      Either MixedVariable (Constant, Relation)
    evaluateMinValue current@(currentMin, _) (Assertion rel expr) = do
      value <- evaluateExpr expr assignment
      return $
        if (value < currentMin) || (value == currentMin && rel == LessThan)
          then (value, rel)
          else current

    evaluateMaxValue ::
      (Constant, Relation) ->
      FMAssertion ->
      Either MixedVariable (Constant, Relation)
    evaluateMaxValue current@(currentMax, _) (Assertion rel expr) = do
      value <- evaluateExpr expr assignment
      return $
        if (value > currentMax) || (value == currentMax && rel == LessThan)
          then (value, rel)
          else current

currentPass :: Doc a
currentPass = "Fourier-Motzkin elimination"
