module Vehicle.Backend.Prelude where

import Control.Monad.IO.Class
import Data.Text.IO qualified as TIO
import Paths_vehicle qualified as VehiclePath
import System.Directory (createDirectoryIfMissing)
import System.FilePath (takeDirectory)
import Vehicle.Prelude
import Vehicle.Verify.Core

--------------------------------------------------------------------------------
-- Differentiable logics

-- | Different ways of translating from the logical constraints to loss functions.
data DifferentiableLogic
  = DL2
  | Godel
  | Lukasiewicz
  | Product
  | Yager
  | STL
  deriving (Eq, Show, Read, Bounded, Enum)

instance Pretty DifferentiableLogic where
  pretty = pretty . show

--------------------------------------------------------------------------------
-- Interactive theorem provers

data ITP
  = Agda
  deriving (Eq, Show, Read, Bounded, Enum)

instance Pretty ITP where
  pretty = \case
    Agda -> "Agda"

--------------------------------------------------------------------------------
-- Different type-checking modes

data TypingSystem
  = Standard
  | Polarity
  | Linearity
  deriving (Eq, Show)

--------------------------------------------------------------------------------
-- Action

data Task
  = TypeCheck TypingSystem
  | CompileToITP ITP
  | CompileToQueryFormat QueryFormatID
  | CompileToLossFunction DifferentiableLogic
  deriving (Eq, Show)

pattern CompileToAgda :: Task
pattern CompileToAgda = CompileToITP Agda

pattern CompileToMarabouQueries :: Task
pattern CompileToMarabouQueries = CompileToQueryFormat MarabouQueryFormat

pattern LossFunctionDL2 :: Task
pattern LossFunctionDL2 = CompileToLossFunction DL2

pattern LossFunctionGodel :: Task
pattern LossFunctionGodel = CompileToLossFunction Godel

pattern LossFunctionLukasiewicz :: Task
pattern LossFunctionLukasiewicz = CompileToLossFunction Lukasiewicz

pattern LossFunctionProduct :: Task
pattern LossFunctionProduct = CompileToLossFunction Product

pattern LossFunctionYager :: Task
pattern LossFunctionYager = CompileToLossFunction Yager

pattern LossFunctionSTL :: Task
pattern LossFunctionSTL = CompileToLossFunction STL

instance Pretty Task where
  pretty = \case
    TypeCheck _ -> "TypeCheck"
    CompileToITP x -> pretty $ show x
    CompileToQueryFormat x -> pretty x
    CompileToLossFunction _ -> "LossFunction"

instance Read Task where
  readsPrec _d x = case x of
    "Marabou" -> [(CompileToMarabouQueries, [])]
    "LossFunction" -> [(LossFunctionDL2, [])]
    -- \|this is a default loss translation
    "LossFunction-DL2" -> [(LossFunctionDL2, [])]
    "LossFunction-Godel" -> [(LossFunctionGodel, [])]
    "LossFunction-Lukasiewicz" -> [(LossFunctionLukasiewicz, [])]
    "LossFunction-Product" -> [(LossFunctionProduct, [])]
    "LossFunction-Yager" -> [(LossFunctionYager, [])]
    "LossFunction-STL" -> [(LossFunctionSTL, [])]
    "Agda" -> [(CompileToAgda, [])]
    "TypeCheck" -> [(TypeCheck Standard, [])]
    "LinearityCheck" -> [(TypeCheck Linearity, [])]
    "PolarityCheck" -> [(TypeCheck Polarity, [])]
    _ -> []

-- | Generate the file header given the token used to start comments in the
--  target language
prependfileHeader :: Doc a -> Maybe ExternalOutputFormat -> Doc a
prependfileHeader doc format = case format of
  Nothing -> doc
  Just ExternalOutputFormat {..} ->
    vsep
      ( map
          (commentToken <+>)
          [ "WARNING: This file was generated automatically by Vehicle",
            "and should not be modified manually!",
            "Metadata:",
            " -" <+> formatName <> " version:" <+> targetVersion,
            " - Vehicle version:" <+> pretty VehiclePath.version
          ]
      )
      <> line
      <> line
      <> doc
    where
      targetVersion = maybe "unknown" pretty formatVersion

writeResultToFile :: MonadIO m => Maybe ExternalOutputFormat -> Maybe FilePath -> Doc a -> m ()
writeResultToFile target filepath doc = do
  let text = layoutAsText $ prependfileHeader doc target
  liftIO $ case filepath of
    Nothing -> TIO.putStrLn text
    Just outputFilePath -> do
      createDirectoryIfMissing True (takeDirectory outputFilePath)
      TIO.writeFile outputFilePath text
