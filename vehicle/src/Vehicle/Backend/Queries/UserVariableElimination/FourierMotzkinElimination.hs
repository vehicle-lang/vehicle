module Vehicle.Backend.Queries.UserVariableElimination.FourierMotzkinElimination
  ( FourierMotzkinVariableSolution,
    fourierMotzkinElimination,
    reconstructFourierMotzkinVariableValue,
  )
where

import Control.Monad (foldM)
import Data.Map (Map)
import GHC.Real (infinity)
import Vehicle.Backend.Queries.UserVariableElimination.Core
import Vehicle.Compile.Error
import Vehicle.Compile.Prelude
import Vehicle.Data.Expr.Linear
import Vehicle.Data.QuantifiedVariable
import Vehicle.Syntax.Builtin (Strictness (..))

-- | TODO If performance proves unnacceptably poor look into
-- Imbert's acceleration theorems:
--
-- Jean-Louis Imbert,
-- About Redundant Inequalities Generated by Fourier's Algorithm
-- Artificial Intelligence IV: Methodology, Systems, Applications, 1990
fourierMotzkinElimination ::
  (MonadCompile m) =>
  UserRationalVariable ->
  [RationalInequality] ->
  m (FourierMotzkinVariableSolution, [RationalInequality])
fourierMotzkinElimination var inequalities = do
  let (less, greater, unusedInequalities) = partition (UserRationalVar var) inequalities
  let solution = FMSolution less greater
  let newInequalities = fmap combineInequalities [(x, y) | x <- less, y <- greater]
  return (solution, newInequalities <> unusedInequalities)

combineInequalities :: (FMBound, FMBound) -> RationalInequality
combineInequalities (FMBound rel1 lowerBound, FMBound rel2 upperBound) =
  RationalInequality
    { rationalIneqExpr = addExprs 1 (-1) lowerBound upperBound,
      strictness = case (rel1, rel2) of
        (Strict, _) -> Strict
        (_, Strict) -> Strict
        (_, _) -> NonStrict
    }

-- | Partitions the inequalities into three sets:
--  1. Those where the rest of the expression is less than the variable
--  2. Those where the rest of the expression is greater than the variable
--  3. Those which don't mention the variable at all.
partition ::
  RationalVariable ->
  [RationalInequality] ->
  ([FMBound], [FMBound], [RationalInequality])
partition var = foldr categorise ([], [], [])
  where
    categorise ::
      RationalInequality ->
      ([FMBound], [FMBound], [RationalInequality]) ->
      ([FMBound], [FMBound], [RationalInequality])
    categorise ineq@(RationalInequality rel expr) (lowerBounds, upperBounds, unused) = do
      let (coeff, valueExpr) = rearrangeExprToSolveFor var expr
      let bound = FMBound rel valueExpr
      if coeff < 0
        then (bound : lowerBounds, upperBounds, unused)
        else
          if coeff > 0
            then (lowerBounds, bound : upperBounds, unused)
            else (lowerBounds, upperBounds, ineq : unused)

--------------------------------------------------------------------------------
-- Solutions

-- | Tries to reconstruct the value of the variable that is
-- consistent with the current assignment of variables. Returns either a
-- required variable that is missing from the assignment or the reconstructed
-- value.
reconstructFourierMotzkinVariableValue ::
  Map RationalVariable Rational ->
  FourierMotzkinVariableSolution ->
  Either RationalVariable Rational
reconstructFourierMotzkinVariableValue assignment solution = do
  let initialMax = (-infinity, NonStrict)
  let initialMin = (infinity, NonStrict)
  (lowerBound, minRel) <- foldM evaluateMaxValue initialMax (lowerBounds solution)
  (upperBound, maxRel) <- foldM evaluateMinValue initialMin (upperBounds solution)

  let validBound =
        lowerBound < upperBound
          -- Turns out `-infinity < infinity` returns `False`
          || lowerBound == -infinity && upperBound == infinity
          || (lowerBound == upperBound && minRel == NonStrict && maxRel == NonStrict)

  if validBound
    then return $ pickValue lowerBound upperBound
    else do
      -- Only 99% sure about this. Can't find a good reference to the reconstruction phase of the
      -- algorithm. Closest to referencing this impossibility is:
      -- https://people.math.carleton.ca/~kcheung/math/notes/MATH5801/02/2_1_fourier_motzkin.html
      developerError "Fourier-Motzkin reconstruction failed. This isn't supposed to be possible..."
  where
    evaluateMinValue ::
      (Rational, Strictness) ->
      FMBound ->
      Either RationalVariable (Rational, Strictness)
    evaluateMinValue current@(currentMin, _) (FMBound rel expr) = do
      value <- evaluateExpr expr assignment
      return $
        if (value < currentMin) || (value == currentMin && rel == Strict)
          then (value, rel)
          else current

    evaluateMaxValue ::
      (Rational, Strictness) ->
      FMBound ->
      Either RationalVariable (Rational, Strictness)
    evaluateMaxValue current@(currentMax, _) (FMBound rel expr) = do
      value <- evaluateExpr expr assignment
      return $
        if (value > currentMax) || (value == currentMax && rel == Strict)
          then (value, rel)
          else current

    pickValue :: Rational -> Rational -> Rational
    pickValue lowerBound upperBound
      | lowerBound == -infinity && upperBound == infinity = 0
      | lowerBound == -infinity = upperBound - 1.0
      | upperBound == infinity = lowerBound + 1.0
      | otherwise = 0.5 * (lowerBound + upperBound)
