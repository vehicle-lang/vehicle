#!/usr/bin/env cabal
{- cabal:
build-depends:
  , base     >=4       && <5
  , containers
  , directory
  , extra
  , filepath
  , process  >=1.2.0.0 && <2

build-tool-depends: stylish-haskell:stylish-haskell
default-language:   Haskell2010
default-extensions: ImportQualifiedPost
ghc-options:        -Wall
-}
import Control.Monad (forM, unless)
import Control.Monad.Extra (partitionM)
import Data.List (isPrefixOf, partition)
import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Maybe ( fromMaybe, listToMaybe )
import System.Directory (doesFileExist)
import System.Environment (getArgs)
import System.Exit (ExitCode (..), exitWith)
import System.FilePath (isRelative, makeRelative, splitDirectories,
                        takeDirectory, (</>))
import System.Process (CreateProcess (..), proc, waitForProcess,
                       withCreateProcess)

main :: IO ()
main = do
  args <- getArgs
  -- Separate out flags from files:
  let (flags, files) = partition ("-" `isPrefixOf`) args

  -- Check that all the file arguments exist:
  (exist, notExist) <- partitionM doesFileExist files
  unless (null notExist) $ fail $ unlines $
    "Error: vehicle-stylish-haskell was called with non-existent file paths:"
      : ["- " <> file | file <- notExist]

  -- Check that all file paths are relative:
  let notRelative = filter (not . isRelative) files
  unless (null notRelative) $ fail $ unlines $
    "Error: vehicle-stylish-haskell was called with non-relative file paths:"
      : ["- " <> file | file <- notExist]

  -- Get all the project root directories:
  let filesByProjectRoot :: Map FilePath [FilePath]
      filesByProjectRoot = foldr insertByProjectRoot Map.empty exist
        where
          insertByProjectRoot file =
            Map.alter (Just . (relativeFile :) . fromMaybe []) projectRoot
            where
              projectRoot = fromMaybe "." .listToMaybe . splitDirectories . takeDirectory $ file
              relativeFile = makeRelative projectRoot file


  -- Check that all project roots have a .stylish-haskell.yaml:
  (projectRoots, projectRootsWithoutStylishHaskellYaml) <-
    partitionM (doesFileExist . (</> ".stylish-haskell.yaml")) (Map.keys filesByProjectRoot)
  unless (null projectRootsWithoutStylishHaskellYaml) $ fail $ unlines $
    "Error: vehicle-stylish-haskell was on projects without .stylish-haskell.yaml:"
      : ["- " <> projectRoot | projectRoot <- projectRootsWithoutStylishHaskellYaml]

  -- Call stylish-haskell for each project root:
  exitCodes <-
    forM projectRoots $ \projectRoot ->
      case Map.lookup projectRoot filesByProjectRoot of
        Nothing -> error "Empty key in filesByProjectRoot"
        Just filesForProjectRoot -> do
          let argsForProjectRoot = flags <> filesForProjectRoot
          let stylishHaskell =
                (proc "stylish-haskell" argsForProjectRoot)
                  {cwd = Just projectRoot}
          withCreateProcess stylishHaskell $
            \_stdin _stdout _stderr processHandle -> do
              -- TODO: assert stream handles are Nothing
              waitForProcess processHandle

  -- Exit with success only if all calls to stylish-haskell succeeded
  let isSuccess ExitSuccess = True
      isSuccess _           = False
  exitWith $ if all isSuccess exitCodes then ExitSuccess else ExitFailure 1
