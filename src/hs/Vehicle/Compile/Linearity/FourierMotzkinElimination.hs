
module Vehicle.Compile.Linearity.FourierMotzkinElimination
  ( fourierMotzkinElimination
  , reconstructFMUserVar
  ) where

import Data.Set (Set)
import Data.Set qualified as Set (toList)
import Data.Vector.Unboxed (Vector)
import Data.Vector.Unboxed as Vector ((!), map)

import Vehicle.Compile.Error
import Vehicle.Compile.Prelude
import Vehicle.Compile.Linearity.Core
import Control.Monad (foldM)

type Solution = (LinearVar, VarReconstruction)

-- TODO If performance proves unnacceptably poor look into
-- Imbert's acceleration theorems:
--
-- Jean-Louis Imbert,
-- About Redundant Inequalities Generated by Fourier's Algorithm
-- Artificial Intelligence IV: Methodology, Systems, Applications, 1990

fourierMotzkinElimination :: MonadCompile m
                          => VariableNames
                          -> Set LinearVar
                          -> [Assertion]
                          -> m ([Solution], [Assertion])
fourierMotzkinElimination varNames varsToSolve assertions =
  logCompilerPass MinDetail currentPass $ do
    logDebug MaxDetail $ prettyAssertions varNames assertions
    let numberedVars = zip [1..] (Set.toList varsToSolve)
    foldM (solveVar varNames) ([], assertions) numberedVars

solveVar :: MonadCompile m
         => VariableNames
         -> ([Solution], [Assertion])
         -> (Int, LinearVar)
         -> m ([Solution], [Assertion])
solveVar varNames (solutions, inequalities) (iteration, var) = do
  let (less, greater, unusedInequalities) = partition var inequalities

  let solution = (var, RecInequalities less greater)

  let newInequalities = fmap combineInequalities [(x,y) | x <- less, y <- greater ]

  let varDoc = pretty $ varNames !! var
  logDebug MaxDetail $
    line <> "After iteration" <+> pretty iteration <+> "solving for" <+> varDoc <> ":" <> line <>
      indent 2 (
        "LHS inequalities:" <>
        prettyAssertions varNames less <> line <>
        "RHS inequalities:" <>
        prettyAssertions varNames greater <> line <>
        "New inequalities:" <>
        prettyAssertions varNames newInequalities
      )

  return (solution : solutions, newInequalities <> unusedInequalities)

combineInequalities :: (Assertion, Assertion) -> Assertion
combineInequalities (Assertion rel1 expr1, Assertion rel2 expr2) =
  let rel = case (rel1, rel2) of
        (LessThan, _) -> LessThan
        (_, LessThan) -> LessThan
        (_, _)        -> LessThanOrEqualTo
  in
  Assertion
  { assertionExpr = addLinearExprs expr1 expr2
  , assertionRel  = rel
  }

-- | Partitions the inequalities into three sets:
--  1. Those where the rest of the expression is less than the variable
--  2. Those where the rest of the expression is greater than the variable
--  3. Those which don't mention the variable at all.
partition :: LinearVar
          -> [Assertion]
          -> ([Assertion], [Assertion], [Assertion])
partition var = foldr categorise ([], [], [])
  where
    categorise :: Assertion
               -> ([Assertion], [Assertion], [Assertion])
               -> ([Assertion], [Assertion], [Assertion])
    categorise a@(Assertion rel (LinearExpr expr)) (less, greater, unused) =
      let coeff = expr Vector.! var in
      if coeff < 0 then
        let coeff' = - coeff in
        let expr' = Vector.map (/ coeff') expr in
        let a' = Assertion rel (LinearExpr expr') in
        (a' : less, greater, unused)
      else if coeff > 0 then
        let expr' = Vector.map (/ coeff) expr in
        let a' = Assertion rel (LinearExpr expr') in
        (less, a' : greater, unused)
      else
        (less, greater, a : unused)


reconstructFMUserVar :: Vector Double
                    -> [Assertion]
                    -> [Assertion]
                    -> Maybe Double
reconstructFMUserVar currentValue less greater = do
  let initialMax = (-1/0, LessThanOrEqualTo)
  let initialMin = (1/0,  LessThanOrEqualTo)
  let (minValue, minRel) = foldr (evaluateMaxValue currentValue) initialMax less
  let (maxValue, maxRel) = foldr (evaluateMinValue currentValue) initialMin greater

  if minValue < maxValue || minRel == LessThanOrEqualTo && maxRel == LessThanOrEqualTo
    then return $ (minValue + maxValue) / 2
    else Nothing
  where
  evaluateMinValue :: Vector Double -> Assertion -> (Double, Relation) -> (Double, Relation)
  evaluateMinValue values (Assertion rel expr) current@(currentMin, _) =
    let value = evaluateExpr expr values in
    if (value < currentMin) || (value == currentMin && rel == LessThan)
      then (value, rel)
      else current

  evaluateMaxValue :: Vector Double -> Assertion -> (Double, Relation) -> (Double, Relation)
  evaluateMaxValue values (Assertion rel expr) current@(currentMax, _) =
    let value = evaluateExpr expr values in
    if (value > currentMax) || (value == currentMax && rel == LessThan)
      then (value, rel)
      else current

currentPass :: Doc a
currentPass = "Fourier-Motzkin elimination"