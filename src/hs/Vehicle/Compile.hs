module Vehicle.Compile
  ( CompileOptions(..)
  , compile
  ) where

import Paths_vehicle qualified as VehiclePath (version)

import Control.Monad.Except (MonadError(..), ExceptT, runExceptT)
import Data.Text as T (Text, pack)
import Data.Text.IO qualified as TIO
import Data.Version (Version, makeVersion)
import System.Exit (exitFailure)

import Vehicle.Prelude
import Vehicle.Language.AST
import Vehicle.Compile.Error
import Vehicle.Compile.Error.Meaningful
import Vehicle.Compile.Parse
import Vehicle.Compile.Elaborate.Frontend as Frontend (runElab)
import Vehicle.Compile.Scope (scopeCheck)
import Vehicle.Compile.Type (typeCheck)
import Vehicle.Compile.Normalise (normalise)

import Vehicle.Compile.Backend.SMTLib (compileToSMTLib, SMTDoc(..))
import Vehicle.Compile.Backend.VNNLib (compileToVNNLib, VNNLibDoc(..))
import Vehicle.Compile.Backend.Agda (compileToAgda, AgdaOptions(..))

data CompileOptions = CompileOptions
  { inputFile      :: FilePath
  , outputFile     :: Maybe FilePath
  , outputTarget   :: OutputTarget
  , moduleName     :: String
  } deriving (Show)

compile :: LogFilePath -> CompileOptions -> IO ()
compile logFile opts@CompileOptions{..} = do
  contents  <- TIO.readFile inputFile
  typedProg <- fromLoggedEitherIO logFile (runTypeCheck contents)

  -- Compile to requested backend
  case outputTarget of
    target@(ITP itp) -> do
      case itp of
        Agda -> do
          let agdaOptions = AgdaOptions "TODO_projectFile" [T.pack moduleName] mempty
          agdaDoc <- fromLoggedEitherIO logFile $ compileToAgda agdaOptions typedProg
          writeResultToFile opts target agdaDoc

    (Verifier verifier) -> do
      normProg <- fromLoggedEitherIO logFile $ normalise typedProg
      case verifier of
        SMTLib -> toSMTLib logFile opts normProg
        VNNLib -> toVNNLib logFile opts normProg

runTypeCheck :: (MonadLogger m, MonadError CompileError m)
             => Text -> m CheckedProg
runTypeCheck txt = do
  bnfcProg    <- parseVehicle txt
  vehicleProg <- runElab bnfcProg
  scopedProg  <- scopeCheck vehicleProg
  typedProg   <- typeCheck scopedProg
  return typedProg

fromEitherIO :: Either CompileError a -> IO a
fromEitherIO (Left err) = do print $ details err; exitFailure
fromEitherIO (Right x)  = return x

fromLoggedEitherIO :: LogFilePath -> ExceptT CompileError Logger a -> IO a
fromLoggedEitherIO logFile x = fromEitherIO =<< fromLoggedIO logFile (runExceptT x)

fromLoggedIO :: LogFilePath -> Logger a -> IO a
fromLoggedIO Nothing        logger = return $ discardLogger logger
fromLoggedIO (Just logFile) logger = flushLogs logFile logger

writeResultToFile :: CompileOptions -> OutputTarget -> Doc a -> IO ()
writeResultToFile CompileOptions{..} target doc = do
  let fileHeader = makefileHeader target
  let outputText = layoutAsText (fileHeader <> line <> line <> doc)
  case outputFile of
    Nothing             -> TIO.putStrLn outputText
    Just outputFilePath -> TIO.writeFile outputFilePath outputText

toSMTLib :: LogFilePath -> CompileOptions -> CheckedProg -> IO ()
toSMTLib logFile options prog = do
  propertyDocs <- fromLoggedEitherIO logFile (compileToSMTLib prog)
  mapM_ (\doc -> writeResultToFile options (Verifier SMTLib) (text doc)) propertyDocs

toVNNLib :: LogFilePath -> CompileOptions -> CheckedProg -> IO ()
toVNNLib logFile options prog = do
  propertyDocs <- fromLoggedEitherIO logFile (compileToVNNLib prog)
  mapM_ (\doc -> writeResultToFile options (Verifier VNNLib) (text (smtDoc doc))) propertyDocs

-- |Generate the file header given the token used to start comments in the
-- target language
makefileHeader :: OutputTarget -> Doc a
makefileHeader target = vsep $
  map (commentTokenOf target <+>)
    [ "WARNING: This file was generated automatically by Vehicle"
    , "and should not be modified manually!"
    , "Metadata"
    , " -" <+> pretty (show target) <> " version:" <+> targetVersion
    , " - AISEC version:" <+> pretty VehiclePath.version
    , " - Time generated: ???"
    ]
  where targetVersion = maybe "N/A" pretty (versionOf target)

versionOf :: OutputTarget -> Maybe Version
versionOf target = case target of
  Verifier VNNLib        -> Nothing
  Verifier SMTLib        -> Nothing
  ITP Agda               -> Just $ makeVersion [2,6,2]

commentTokenOf :: OutputTarget -> Doc a
commentTokenOf = \case
  Verifier VNNLib        -> ";"
  Verifier SMTLib        -> ";"
  ITP Agda               -> "--"