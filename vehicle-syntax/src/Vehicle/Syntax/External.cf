-- Grammar of the Vehicle External language

comment "--";
comment "{-" "-}";

-- * Tokens

-- NOTE: Token rules are tried IN ORDER, so the order matters!
position token Boolean  ({"True"} | {"False"});
position token Natural  (digit+);
position token Rational (digit+ '.' digit+);

position token TokNetwork   {"@network"};
position token TokDataset   {"@dataset"};
position token TokParameter {"@parameter"};
position token TokProperty  {"@property"};

position token TokArrow     {"->"};
position token TokForallT   {"forallT"};
position token TokIf        {"if"};
position token TokThen      {"then"};
position token TokElse      {"else"};
position token TokDot       {"."};
position token TokElemOf    {":"};
position token TokLambda    {"\\"};
position token TokLet       {"let"};

position token TokUnit      {"Unit"};
position token TokBool      {"Bool"};
position token TokNat       {"Nat"};
position token TokInt       {"Int"};
position token TokRat       {"Rat"};
position token TokVector    {"Vector"};
position token TokTensor    {"Tensor"};
position token TokList      {"List"};
position token TokIndex     {"Index"};

position token TokForall    {"forall"};
position token TokExists    {"exists"};
position token TokForeach   {"foreach"};
position token TokImpl      {"=>"};
position token TokAnd       {"and"};
position token TokOr        {"or"};
position token TokNot       {"not"};
position token TokEq        {"=="};
position token TokNeq       {"!="};
position token TokLe        {"<="};
position token TokLt        {"<"};
position token TokGe        {">="};
position token TokGt        {">"};
position token TokMul       {"*"};
position token TokDiv       {"/"};
position token TokAdd       {"+"};
position token TokSub       {"-"};

position token TokNil       {"nil"};
position token TokSeqOpen   {"["};
position token TokSeqClose  {"]"};
position token TokCons      {"::"};
position token TokAt        {"!"};
position token TokMap       {"map"};
position token TokFold      {"fold"};

position token Name        (letter (letter | digit | '_')*) ;
position token HoleToken   ({"?"} (letter | digit | '_')*);
position token TypeToken   ({"Type"} digit+);

position token DeclAnnOptionValue ((letter | digit)+);

separator Name "";


-- * Binders

ExplicitBinder.    Binder ::= Name;
ExplicitBinderAnn. Binder ::= "(" Name TokElemOf Expr1 ")";
ImplicitBinder.    Binder ::= "{" Name "}";
ImplicitBinderAnn. Binder ::= "{" Name TokElemOf Expr1 "}";
InstanceBinder.    Binder ::= "{{" Name "}}";
InstanceBinderAnn. Binder ::= "{{" Name TokElemOf Expr1 "}}";

separator Binder "";

-- * Arguments

ExplicitArg. Arg ::= Expr15;
ImplicitArg. Arg ::= "{" Expr1 "}";
InstanceArg. Arg ::= "{{" Expr1 "}}";

-- * Individual let declarations

LDecl. LetDecl ::= Binder "=" Expr;

separator LetDecl ",";

-- * Literals

UnitLiteral.  Lit ::= "()";
NatLiteral.   Lit ::= Natural;
RatLiteral.   Lit ::= Rational;
BoolLiteral.  Lit ::= Boolean;


-- * Expressions

-- NOTE:
--
--   The syntax for expressions used by the parser is more general than that
--   permitted by our bidirectional typing, which allows us to emit an more
--   specific error message when we're missing a type annotation, rather than
--   emitting a parse error.
--
--   See https://github.com/BNFC/bnfc/issues/372 for why tokens
--   aren't used for `let` and `in`.

-- Kinds.
Type.    Expr15 ::= TypeToken;

-- Core structure.
Ann.     Expr   ::= Expr2 TokElemOf Expr1;
ForallT. Expr1  ::= TokForallT [Binder] TokDot Expr1;
Let.     Expr2  ::= TokLet [LetDecl] "in" Expr2;
Lam.     Expr2  ::= TokLambda [Binder] TokArrow Expr2;
Fun.     Expr11 ::= Expr13 TokArrow Expr11;
App.     Expr13 ::= Expr13 Arg;
Var.     Expr15 ::= Name;
Literal. Expr15 ::= Lit;
Hole.    Expr15 ::= HoleToken;

-- Quantification
Forall.    Expr2 ::= TokForall  [Binder] TokDot Expr2;
Exists.    Expr2 ::= TokExists  [Binder] TokDot Expr2;
ForallIn.  Expr2 ::= TokForall  [Binder] "in" Expr3 TokDot Expr2;
ExistsIn.  Expr2 ::= TokExists  [Binder] "in" Expr3 TokDot Expr2;

Foreach.   Expr2 ::= TokForeach [Binder] TokDot Expr2;

-- Boolean expressions.
If.      Expr4  ::= TokIf Expr5 TokThen Expr5 TokElse Expr5;
Impl.    Expr5  ::= Expr6 TokImpl Expr5;
And.     Expr7  ::= Expr8 TokAnd Expr7;
Or.      Expr7  ::= Expr8 TokOr  Expr7;
Eq.      Expr8  ::= Expr9 TokEq  Expr9;
Neq.     Expr8  ::= Expr9 TokNeq Expr9;
Not.     Expr11 ::= TokNot Expr11;

-- Numeric expressions.
Le.      Expr8  ::= Expr8  TokLe  Expr9;
Lt.      Expr8  ::= Expr8  TokLt  Expr9;
Ge.      Expr8  ::= Expr8  TokGe  Expr9;
Gt.      Expr8  ::= Expr8  TokGt  Expr9;
Add.     Expr9  ::= Expr9  TokAdd Expr10;
Sub.     Expr9  ::= Expr9  TokSub Expr10;
Mul.     Expr10 ::= Expr10 TokMul Expr11;
Div.     Expr10 ::= Expr10 TokDiv Expr11;
Neg.     Expr11 ::= TokSub Expr11;

-- Lists and vectors.
VecLiteral. Expr15 ::= TokSeqOpen [Expr] TokSeqClose;
Nil.        Expr15 ::= TokNil;
Cons.       Expr4  ::= Expr5 TokCons Expr4;
At.         Expr12 ::= Expr12 TokAt Expr13;
Map.        Expr13 ::= TokMap Expr15 Expr15;
Fold.       Expr13 ::= TokFold Expr15 Expr15 Expr15;

-- Primitive types.
Unit.    Expr15 ::= TokUnit;
Bool.    Expr15 ::= TokBool;
Rat.     Expr15 ::= TokRat;
Int.     Expr15 ::= TokInt;
Nat.     Expr15 ::= TokNat;
List.    Expr14 ::= TokList;
Vector.  Expr14 ::= TokVector;
Tensor.  Expr14 ::= TokTensor;
Index.   Expr14 ::= TokIndex;

coercions Expr 15;
separator Expr ",";

-- * Annotations

Network.   DeclAnnName ::= TokNetwork;
Dataset.   DeclAnnName ::= TokDataset;
Parameter. DeclAnnName ::= TokParameter;
Property.  DeclAnnName ::= TokProperty;

-- * Annotation options

BooleanOption. DeclAnnOption ::= Name "=" Boolean;

separator DeclAnnOption ",";

-- * Declarations annotations

DeclAnnWithOpts.    DeclAnnOpts ::= "(" [DeclAnnOption] ")";
DeclAnnWithoutOpts. DeclAnnOpts ::= "";

-- * Declarations


DefAnn.       Decl ::= DeclAnnName DeclAnnOpts;
DefType.      Decl ::= "type" Name [Binder] "=" Expr;
DefFunType.   Decl ::= Name TokElemOf Expr;
DefFunExpr.   Decl ::= Name [Binder] "=" Expr;

separator Decl ";";

-- * Program

layout toplevel;

Main. Prog ::= [Decl]
