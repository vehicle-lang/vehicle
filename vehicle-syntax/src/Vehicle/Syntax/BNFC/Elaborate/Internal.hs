module Vehicle.Syntax.BNFC.Elaborate.Internal
  ( elab
  ) where

import Control.Monad.Except (MonadError (..))
import Control.Monad.Reader (MonadReader(..))
import Data.List.NonEmpty (NonEmpty (..))
import Data.Text (Text)
import Data.Text qualified as Text
import Numeric (readFloat)
import Prettyprinter (Pretty (..), (<+>))

import Vehicle.Syntax.Internal.Abs as B

import Vehicle.Syntax.AST qualified as V
import Vehicle.Syntax.AST.Name
import Vehicle.Syntax.AST.Provenance
import Vehicle.Syntax.AST.Relevance
import Vehicle.Syntax.AST.Visibility
import Vehicle.Syntax.Parse.Error (ParseError (..))
import Vehicle.Syntax.Parse.Token (IsToken, Token (..), tkSymbol, toToken)
import Vehicle.Syntax.Prelude (developerError, readNat, readRat)

--------------------------------------------------------------------------------
-- Conversion from BNFC AST
--
-- We convert from the simple AST generated automatically by BNFC to our
-- more complicated internal version of the AST which allows us to annotate
-- terms with sort-dependent types.
--
-- While doing this, we
--
--   1) extract the positions from the tokens generated by BNFC and convert them
--   into `Provenance` annotations.
--
--   2) convert the builtin strings into `Builtin`s

type MonadElab m =
  ( MonadError ParseError m
  , MonadReader Module m
  )

class Elab vf vc where
  elab :: MonadElab m => vf -> m vc

instance Elab B.Prog V.InputProg where
  elab (B.Main ds) = V.Main <$> traverse elab ds

instance Elab B.Decl V.InputDecl where
  elab = \case
    B.DeclNetw      n t   -> elabResource n t V.Network
    B.DeclData      n t   -> elabResource n t V.Dataset
    B.DeclParam     n t   -> elabResource n t V.Parameter
    B.DeclImplParam n t   -> elabResource n t V.InferableParameter
    B.DefFun        n t e -> V.DefFunction  (tkProvenance n) <$> elab n <*> pure False <*> elab t <*> elab e
    B.DeclPost      n t   -> V.DefPostulate (tkProvenance n) <$> elab n <*> elab t

elabResource :: MonadElab m => NameToken -> B.Expr -> V.Resource -> m V.InputDecl
elabResource n t r = V.DefResource (tkProvenance n) <$> elab n <*> pure r <*> elab t

instance Elab B.Expr V.InputExpr where
  elab = \case
    B.Type l           -> return $ convType l
    B.Hole name        -> return $ V.Hole (tkProvenance name) (tkSymbol name)
    B.Ann term typ     -> op2 V.Ann  <$> elab term <*> elab typ
    B.Pi  binder expr  -> op2 V.Pi   <$> elab binder <*> elab expr;
    B.Lam binder e     -> op2 V.Lam  <$> elab binder <*> elab e
    B.Let binder e1 e2 -> op3 V.Let  <$> elab e1 <*> elab binder <*>  elab e2
    B.LVec es          -> op1 V.LVec <$> traverse elab es
    B.Builtin c        -> V.Builtin (mkAnn c) <$> lookupBuiltin c
    B.Var n            -> return $ V.Var (mkAnn n) (tkSymbol n)
    B.Literal v        -> V.Literal mempty <$> elab v

    B.App fun arg -> do
      fun' <- elab fun
      arg' <- elab arg
      let p = fillInProvenance (provenanceOf fun' :| [provenanceOf arg'])
      return $ V.normApp p fun' (arg' :| [])

instance Elab B.Binder V.InputBinder where
  elab = \case
    B.RelevantExplicitBinder   n e -> mkBinder n Explicit Relevant e
    B.RelevantImplicitBinder   n e -> mkBinder n Implicit Relevant e
    B.RelevantInstanceBinder   n e -> mkBinder n Instance Relevant e
    B.IrrelevantExplicitBinder n e -> mkBinder n Explicit Irrelevant e
    B.IrrelevantImplicitBinder n e -> mkBinder n Implicit Irrelevant e
    B.IrrelevantInstanceBinder n e -> mkBinder n Instance Irrelevant e
    where
      mkBinder :: MonadElab m => B.NameToken -> V.Visibility -> V.Relevance -> B.Expr -> m V.InputBinder
      mkBinder n v r e = V.Binder (mkAnn n) v r (Just (tkSymbol n)) <$> elab e

instance Elab B.Arg V.InputArg where
  elab = \case
    B.RelevantExplicitArg   e -> mkArg Explicit Relevant   <$> elab e
    B.RelevantImplicitArg   e -> mkArg Implicit Relevant   <$> elab e
    B.RelevantInstanceArg   e -> mkArg Instance Relevant   <$> elab e
    B.IrrelevantExplicitArg e -> mkArg Explicit Irrelevant <$> elab e
    B.IrrelevantImplicitArg e -> mkArg Implicit Irrelevant <$> elab e
    B.IrrelevantInstanceArg e -> mkArg Instance Irrelevant <$> elab e
    where
      mkArg :: V.Visibility -> V.Relevance -> V.InputExpr -> V.InputArg
      mkArg v r e = V.Arg (expandByArgVisibility v (provenanceOf e)) v r e

instance Elab B.Lit V.Literal where
  elab = \case
    B.UnitLiteral   -> return V.LUnit
    B.BoolLiteral b -> return $ V.LBool (read (Text.unpack $ tkSymbol b))
    B.RatLiteral  r -> return $ V.LRat  (readRat (tkSymbol r))
    B.NatLiteral  n -> return $ V.LNat  (readNat (tkSymbol n))

instance Elab B.NameToken V.Identifier where
  elab n = do
    mod <- ask
    return $ Identifier mod $ tkSymbol n

lookupBuiltin :: MonadElab m => B.BuiltinToken -> m V.Builtin
lookupBuiltin (BuiltinToken tk) = case V.builtinFromSymbol (tkSymbol tk) of
  Just v  -> return v
  Nothing -> do
    let token = toToken tk
    throwError $ UnknownBuiltin (tkProvenance token) (tkSymbol token)


mkAnn :: IsToken a => a -> V.Provenance
mkAnn = tkProvenance

op1 :: (V.HasProvenance a)
    => (V.Provenance -> a -> b)
    -> a -> b
op1 mk t = mk (provenanceOf t) t

op2 :: (V.HasProvenance a, V.HasProvenance b)
    => (V.Provenance -> a -> b -> c)
    -> a -> b -> c
op2 mk t1 t2 = mk (provenanceOf t1 <> provenanceOf t2) t1 t2

op3 :: (V.HasProvenance a, V.HasProvenance b, V.HasProvenance c)
    => (V.Provenance -> a -> b -> c -> d)
    -> a -> b -> c -> d
op3 mk t1 t2 t3 = mk (provenanceOf t1 <> provenanceOf t2 <> provenanceOf t3) t1 t2 t3

-- | Elabs the type token into a Type expression.
-- Doesn't run in the monad as if something goes wrong with this, we've got
-- the grammar wrong.
convType :: TypeToken -> V.InputExpr
convType tk = case Text.unpack (tkSymbol tk) of
  ('T':'y':'p':'e':l) -> V.Universe (mkAnn tk) (V.TypeUniv (read l))
  t                   -> developerError $ "Malformed type token" <+> pretty t
